#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ctex-article
\use_default_options true
\maintain_unincluded_children false
\language chinese-simplified
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 2cm
\rightmargin 1cm
\bottommargin 2cm
\secnumdepth 4
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 4text%
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
基于双目立体相机的环境感知
\end_layout

\begin_layout Section
文档范畴以及说明
\end_layout

\begin_layout Standard
本文档阐述在移动机器人领域，如何使用双目立体相机来感知环境，以完成避障以及局部路径规划。本文档只含有离线情形下的研发，不涉及在线（在无人车）上的研发。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
文档内容的一些说明。
\end_layout

\begin_layout Standard
有“--”前缀的标题。含有不成型，或者即将被遗弃的内容。
\end_layout

\begin_layout Standard
正文中的“==”。之后的内容是草稿，也就是尚未整理的。
\end_layout

\begin_layout Section
术语
\end_layout

\begin_layout Standard
帧对（frame pair）。双目相机一次拍摄会包含左右各一帧图像，我们将其称为一个帧对。
\end_layout

\begin_layout Section
原理
\end_layout

\begin_layout Standard
disparity map。https://www.baeldung.com/cs/disparity-map-stereo-vision。人眼使用双目成像来获得一
个物体的深度信息。双目相机模拟人眼的这个能力。disparity指的是物体在一对儿立体图像中的表面上的移动。为了体验这点，可以做一个简单的实验。首先，确定自己的
双眼在当前时刻哪个是主力眼。然后，用一只手遮挡住主力眼，在鼻子前10厘米左右竖起另外一只手的一个指头，记住该指头在更远距离的物体比如计算机屏幕上指向什么物体。然
后，将遮挡在主力眼前面的手迅速撤掉，可以感觉到指头所指的物体移动到了另外一个位置。
\end_layout

\begin_layout Standard
给定一对儿图像，利用某种算法估计左边图像中的每个像素点和右边图像的哪个像素点是源自于物理世界的同一个点的，然后再计算它们之间的位移，最终，可以得到一个维度和上述
两个图像一样的图，每个像素的值表示的是这个偏离程度。如果还知道两个摄像头之间的距离，很容易从这个视差图推算出每个像素点对应的物理点和摄像头的距离。下图是一个例子
。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/disparity-map.png
	width 50text%
	groupId half

\end_inset


\end_layout

\begin_layout Standard
算法。主要有以下两种：block-matching（出现的较早，@lsd-20所引用的一个为2007年），以及基于深度神经网络的（出现的较晚，@lsd-20所引
用的一个为2016年）。后者的效果更好。
\end_layout

\begin_layout Section
细化的研发目标
\end_layout

\begin_layout Standard
环境中一些典型障碍物如下。
\end_layout

\begin_layout Standard
便道牙。
\end_layout

\begin_layout Standard
行人。包括静止的以及移动的。
\end_layout

\begin_layout Standard
汽车。包括静止的以及移动的。
\end_layout

\begin_layout Standard
树木。
\end_layout

\begin_layout Standard
墙壁。
\end_layout

\begin_layout Standard
垃圾桶。
\end_layout

\begin_layout Standard
沟渠。
\end_layout

\begin_layout Standard
草坪。
\end_layout

\begin_layout Standard
白墙。
\end_layout

\begin_layout Standard
玻璃门。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
用户给定大致移动方向（前、后、左、右、左前等），机器人自主决定精确的行进方向与速度。具体地，需要实现以下任务。
\end_layout

\begin_layout Enumerate
在指定的行进方向上是否有障碍物。有以下考虑。
\end_layout

\begin_deeper
\begin_layout Enumerate
由于机器人的越障能力差，只要行进方向上有超过越障最大高度的物体，就应该将其判定为障碍物。
\end_layout

\end_deeper
\begin_layout Enumerate
指定的行进方向上的路面是否适合机器人进入。例如，不能进入草坪、水渠等处。
\end_layout

\begin_layout Standard
也就是说，输入为用户指定的大致方向，输出为向小车发出的动作指令，决策的依据是小车当时的环境。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
本项目目前不考虑以下目标：
\end_layout

\begin_layout Standard
- 能够感知后部以及周围的环境，以执行倒车。
\end_layout

\begin_layout Standard
原因是这对无人车平台的硬件有更高要求。
\end_layout

\begin_layout Section
sw机器
\end_layout

\begin_layout Subsection
机器的远程开启与关闭
\end_layout

\begin_layout Standard
小组中有一些专门用于计算的机器供小组成员共享使用。通过使用这类机器，成员可以获得更高的算力、磁盘容量，也可以方便地和别的小组成员共享代码、数据等。由于这类机器的
电源功耗较大，我们并不是令它们24小时开机，而是只在需要的时候远程开启它们。以下以目前这类机器的一台为例来讲解，其名字为sw。我们的思路是：使用一个24小时开启
的低功率机器（一个树莓派，将其命名为pi）来执行上述开启sw的操作。为了能够使得用户（以岳夏薇为例，其用户名为yxw）从远程（例如泰达校区）的局域网能够访问位于
另外一个局域网的上述机器，我们使用一个工具frp，关于该工具的原理以及用法，参git项目sharedKnowledge中tools目录下的文档。
\end_layout

\begin_layout Standard
整个访问的流程如下。
\end_layout

\begin_layout Standard
1.
 登录机器pi。执行以下命令：
\end_layout

\begin_layout Standard
ssh -oPort=7000 zb@43.138.33.134
\end_layout

\begin_layout Standard
用户应该可以登录到机器pi上，验证的方法是看屏幕输出的首行为：
\end_layout

\begin_layout Standard
Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.4.0-1093-raspi aarch64)
\end_layout

\begin_layout Standard
解释。机器pi上运行有frp的客户端，用户通过公网上的frp服务器的转发，能够远程登录机器pi。上述命令中的“zb”是机器pi中的一个用户。
\end_layout

\begin_layout Standard
2.
 执行以下命令唤醒sw机器：
\end_layout

\begin_layout Standard
bin/swon
\end_layout

\begin_layout Standard
解释。该命令向sw机器发送一个特殊的网络数据包，唤醒本处于suspended状态的机器sw。
\end_layout

\begin_layout Standard
3.
 执行exit命令退出机器pi的登录。
\end_layout

\begin_layout Standard
4.
 等待1分钟左右，执行以下命令登录机器sw。
\end_layout

\begin_layout Standard
ssh -oPort=5000 yxw@43.138.33.134
\end_layout

\begin_layout Standard
如果成功登录，能够看到“zb@sw”的提示符。
\end_layout

\begin_layout Standard
解释。
\end_layout

\begin_layout Standard
A.机器sw上运行有frp的客户端，用户通过公网上的frp服务器的转发，能够远程登录该机器。上述命令中的“yxw”是机器sw中的一个用户。
\end_layout

\begin_layout Standard
B.目前已经创建的用户有：gx，chyr，zhry，分别表示龚熙，陈寅瑞，张蕊怡。初始密码和用户名一样。各人应该使用自己的账户，比如在自己账户下创建一个符号链接，
指向某个大容量磁盘中的文件夹（参下文）。
\end_layout

\begin_layout Standard
C.这个步骤之所以要等待1分钟左右，是由于sw机器从suspended到正常运行状态需要一定的时间。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
5.
 使用完毕后，执行命令“off”，令机器sw在两分钟之后重新回到suspended节能状态。当提示输入密码时，输入自己账户的密码（比如账户yxw的是yxw）。
\end_layout

\begin_layout Standard
6.
 执行exit命令退出机器sw的登录。
\end_layout

\begin_layout Subsection
一些约定
\end_layout

\begin_layout Subsubsection
程序（脚本）和数据分离
\end_layout

\begin_layout Standard
每个人员开发的程序（以及关联的脚本）应该和程序的输入输出数据分开存放。这个做法便于分别管理它们。例如，对于程序以及脚本，可以采用git管理。对于数据，其中的中间
实验数据可以在一个实验结束被删除。
\end_layout

\begin_layout Subsubsection
远程开发的流程
\end_layout

\begin_layout Standard
设一个成员需要实现一个功能（比如将深度图转换为点云图），远程开发的流程如下：
\end_layout

\begin_layout Standard
1.在git项目oa的工作目录（比如/sw/obstacleAvoidance）下，创建一个子目录，用于存放完成该功能的程序以及脚本。这些文件默认将被纳入git管
理。开发者只用git命令比如add，commit，push等管理这些源代码。
\end_layout

\begin_layout Standard
不要在/sw/obstacleAvoidance目录下创建太多的子目录，否则不容易管理。应该将具有逻辑联系的项目目录归入到一个子目录中。例如，为了将KITTI数
据集中的真值深度图转换为点云图，张波编写了程序generateDepthHDF5以及depthToPointCloudMap，这些程序就会被纳入到一个目录kit
tiDepthToPointCloudMap。
\end_layout

\begin_layout Standard
2.
 开发者在自己本地的机器完成上述程序的构建。
\end_layout

\begin_layout Standard
3.
 开发者编写一个脚本，能够将上述构建完毕的程序通过scp复制到sw机器的某些目录。
\end_layout

\begin_layout Standard
4.
 开发者通过ssh登录sw机器，在sw机器上运行自己的程序。
\end_layout

\begin_layout Standard
5.开发者在sw机器上直接查看生成的数据是否正确，这是被推荐的方式。如果网络带宽无法满足流畅地查看数据的要求，开发者可以将数据从sw机器下载到本地在查看。
\end_layout

\begin_layout Subsubsection
实验数据存放位置
\end_layout

\begin_layout Standard
每个人在/ext或者/l创建一个子目录，然后将自己产生的数据存放在该子目录。可以读取上述目录下他人已经生成的数据。给所创建的子目录起名字时，应该依据数据本身的角
色，而不是一个成员自己的名字或者用户名。上述目录/l实际是/mnt/seagate16t的一个符号链接，有14T可用。不要在/home那个目录中存放，因为其容量
很小。一些常见的目录如下。
\end_layout

\begin_layout Standard
目录/sw/cv/dbase。存放从网上获得的其他数据集。这些目录是只读的，各个成员不应该删除其中的内容。
\end_layout

\begin_layout Standard
目录/sw/cv/exp。其中sw实际上指向ext/seeWorld子目录，而子目录cv/exp被用来存放oa项目中和计算机视觉相关的实验数据。这些数据在实验做
完之后是可以被删除的。
\end_layout

\begin_layout Section
避障领域文献综述
\end_layout

\begin_layout Subsection
文献
\end_layout

\begin_layout Standard
关键字。
\end_layout

\begin_layout Standard
Stereo Camera; Obstacle detection; obstacle avoidance; depth map; fuzzy
 controller;
\end_layout

\begin_layout Standard
Unmanned Ground Vehicles (UGVs)
\end_layout

\begin_layout Standard
有些文章报告在无人机中使用ZED避障。其任务和地面轮式机器人的不同。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
英文的参Zotero中的。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
中文社区的。.
\end_layout

\begin_layout Standard
基于双目立体视觉的障碍物检测研究，魏立松，西安电子科技大学，2019年。讨论底层算法，静态、动态障碍物的检测。p.20，有一个图，比较这几款相机（ZED，Bumb
leBee，小觅）的性能。
\end_layout

\begin_layout Standard
基于双目立体视觉的障碍物检测技术研究与实现，高峰，北京邮电大学，2019年。主要讨论如何从双目图像获得深度信息，有一小部分讨论障碍物检测。
\end_layout

\begin_layout Standard
https://cdmd.cnki.com.cn/Article/CDMD-10710-1021890106.htm，大部分工作是研究如何获得深度信息的。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://paperswithcode.com/paper/obstacle-avoidance-using-stereo-camera，2017年的一篇，
从摘要看只是使用很简单的算法，没有用到SLAM或者深度网络。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
视频。
\end_layout

\begin_layout Standard
Obstacle detection for a vehicle equipped with an embedded stereo camera,
 https://www.youtube.com/watch?v=bt5QxqI__7Q
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
使用其他类型传感器的。
\end_layout

\begin_layout Standard
基于激光传感器的路沿检测，https://zhuanlan.zhihu.com/p/501499633，其中用到神经网络。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://paperswithcode.com/paper/real-time-fusion-network-for-rgb-d-semantic
\end_layout

\begin_layout Standard
https://paperswithcode.com/paper/cmx-cross-modal-fusion-for-rgb-x-semantic
\end_layout

\begin_layout Subsection
概述
\end_layout

\begin_layout Standard
问题描述。识别环境中的道路以及障碍物对人来说非常简单，但是对于机器不容易。ZED输出的深度信息并非环境中的道路以及障碍物信息，需要进行一些处理。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
不同应用中对避障这个任务的定义不同。例如，室内环境下可以认为地面是平的，也可以将所有在地面以上的物体都看做障碍。而无人机应用中却不能这样。因此，实现避障的算法有
多个，运算量也相差的较多，https://stackoverflow.com/questions/6641055/obstacle-avoidance-with-
stereo-vision有些讨论。
\end_layout

\begin_layout Subsection
@lsd-20
\end_layout

\begin_layout Standard
相关的一篇论文是@rni-20，作者机构为ASL，该论文被简称为ASL论文。由于此前我对这个领域一点儿也不了解，所以我仔细阅读该论文，并考虑复现该论文的方法。一
个目的是对该领域有一个具体、深入的理解。并不希望所复现的系统一定满足本项目技术要求。
\end_layout

\begin_layout Standard
瑞士的机构。该论文的目标是使用低算力算法来检测一般的动态物体（顺带也检测静态物体）。宣称基于诸如YOLO的CV算法无法处理一般的动态物体，而且，在计算资源受限时
无法达到实时的性能。使用的是一个灰度双目摄像头（并非ZED）。该论文含有点云图生成算法，对于我们所采用的ZED，其内部已有。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该论文指出，为了能够检测环境中的静态以及动态物体，目前常见的方法是使用激光雷达或者基于CV的摄像头。前者准确但是造价昂贵，后者便宜但是需要高算力以及精心设计的算
法，而且所检测的物体类别是预先定义的。而本论文试图在较便宜的传感器、低算力条件下，检测人以及一般的动态物体。
\end_layout

\begin_layout Standard
无论是激光雷达还是双目相机，所得的点云图信息虽然只是环境信息的一部分，但是所含信息可以作为无人车近距离导航的重要参考信息。由于这种类型数据出现的时间较晚（只是随
着自动驾驶的兴起而兴起），所以其处理方式和传统的图像的不同。对于双目相机生成的点云图，噪音比激光雷达的严重。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
数据集。该论文使用的是自己制作的数据集，并没有使用公开数据集。https://projects.asl.ethz.ch/datasets/doku.php含有ASL公开
的数据集。该网页还提供了多个有用的链接，指向其他多个适用于机器人领域的类似数据集。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
讨论。
\end_layout

\begin_layout Standard
这个论文的价值在于，使用其中的目标检测算法，能够在繁忙的道路（无论是室外还是室内）中使得无人车能够更加充分的利用道路，使得无人车更聪明。如果只使用更保守的算法（
比如仅当检测到车子行进方向上有很大的空间时车子才行进），会使得车子在繁忙道路上龟缩不前。而且，上述保守算法存在着一个风险：如果道路中有速度较快的物体（比如电动车
、汽车等），无人车起初由于检测到的可用空间大，会行进，可是这些快速物体会很快接近无人车，有安全问题。
\end_layout

\begin_layout Standard
本项目属于低速无人车研究领域。我觉得这个领域是随着更广泛的领域“无人驾驶”以及算力提升而在最近这些年发展起来的，属于一个处于初始上升期的研究领域，这和语音识别领
域不同。
\end_layout

\begin_layout Standard
这部分工作相当于赋予任务车一双眼睛。一些对人类立即可用的功能在无人车上是根本没有的，需要开发者通过软硬件来实现。在开发过程中，开发者应该将无人车看做一个起初没有
任何智能的机器，而不能想当然的认为无人车具有人的一些先天能力。
\end_layout

\begin_layout Standard
从该论文看到CV中空间域的图像处理并没有高深的理论，一般是基于人的直觉来开发相关算法。这些算法看起来精细，但是只是研究者长时经验的总结，并不具有普适性。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
局限性。
\end_layout

\begin_layout Enumerate
该论文似乎没有假设采集设备是静止的，没有考虑其运动时的情形，而无人车情形下当然需要考虑。
\begin_inset Newline newline
\end_inset

不过，我觉得应该有这方面的工作可以被借鉴，因为只要机器人是基于双目或者深度相机的，就应该有这方面的工作。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
问题。
\end_layout

\begin_layout Standard
该论文将人作为一种特殊的目标，单独进行检测，是为了能够更加准确的检测到行人，以避免无人车碰到行人。这个检测准确率中将人当做一般动态物体会高多少？
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
相关信息。
\end_layout

\begin_layout Standard
https://asl.ethz.ch/，Autonomous Systems Lab (ASL)。是大学研究机构。有22个博士生？！https://www.zhih
u.com/question/23754353，含有瑞士博士生培养的相关信息。瑞士的教育不错。看起来，在瑞士读博士工作的成分更重，毕业时没有发表论文的要求，奖学金
多，但是中国人从国内难以申请，在瑞士读硕士的倒是比较容易申请，或者，已经获得一些经费支持的容易申请。https://asl.ethz.ch/the-lab/robo
ts.html 列有该机构做的多个机器人，挺厉害。发表了很多文章。其开源项目看起来只是一些模块。
\end_layout

\begin_layout Standard
https://www.sevensense.ai/，Sevensense Robotics AG，研究无人车的视觉系统。公司目标专一，估计规模应该不大。
\end_layout

\begin_layout Subsection
基于SLAM的避障
\end_layout

\begin_layout Standard
也许是并非所有机器人应用都需要建立环境地图，SLAM中的研究中将SLAM用在避障的工作似乎比较少。@lsd-20就是一个典型的例子：使用双目相机来避障，但是根本
没有SLAM的成分。本项目也类似：我们并不需要建立环境的地图，这可以降低系统硬件、算法方面的要求。
\end_layout

\begin_layout Standard
https://zhuanlan.zhihu.com/p/141053131，无人机上的，北航团队的，是一整套软件硬件，包含：立体视觉、运动估计、稠密重建、Slam
导航、路径规划、自主避碍等功能。
\end_layout

\begin_layout Subsection
目标检测的性能测度
\end_layout

\begin_layout Subsubsection
MOTP/MOTA
\end_layout

\begin_layout Standard
文献。@mot-06
\end_layout

\begin_layout Standard
动机。在多目标检测领域，在该文章之前没有统一的、精练的测度来衡量一个检测算法的总体性能。
\end_layout

\begin_layout Standard
论文概述。提出多目标检测中的测度MOTP（multiple objects tracking precision）以及MOTA（multiple
 objects tracking accuracy）。前者测度对于检测到的目标的检测位置精度，后者测度在考虑了时间维度时正确检测出了哪些目标，和语音识别领域的
Word Error Rate类似（只不过MOTA越接近于1表示检测器越准确）。除了上述测度，该论文还有其他方面的内容，但是可以被忽略。该测度的好处：
\end_layout

\begin_layout Enumerate
只有两个量，因而更加精练。
\end_layout

\begin_layout Enumerate
直观、形象。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
评测过程。设输入为：对每一个视频帧
\begin_inset Formula $t$
\end_inset

，目标检测算法输出了
\begin_inset Formula $\{h_{1},...,h_{m}\}$
\end_inset

个假设，实际的目标集合为
\begin_inset Formula $\{o_{1},...,o_{n}\}$
\end_inset

。评测由以下三个步骤组成：
\end_layout

\begin_layout Enumerate
对每个帧
\begin_inset Formula $t$
\end_inset

，建立假设和实际目标之间的关联（correspondence）；
\end_layout

\begin_layout Enumerate
计算位置估计精度；
\end_layout

\begin_layout Enumerate
累积以下类型的错误，我们将它们统称为关联错误：
\end_layout

\begin_deeper
\begin_layout Enumerate
misses。一个这样的错误指的是对一个实际目标没有任何对应的假设；
\end_layout

\begin_layout Enumerate
false positives。一个这样的错误指的是一个假设没有对应任何实际目标；
\end_layout

\begin_layout Enumerate
mismatches。一个这样的错误指的是同一个目标在不同时刻被指定为不同的假设。这种错误常发生在以下场合：当两个物体在视频帧中的距离从大到小然后再变大，或者其
中一个物体遮挡了另外一个物体时。
\end_layout

\end_deeper
\begin_layout Standard
下图显示前两类的错误。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/objectDetectionErrorTypes.png
	width 50text%
	groupId half

\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
下图显示的是mismatches类型的错误，其中h2对应的轨迹先是正确地跟踪了o2，然后在t+3时错误地切换到o1，再在t+5时错误地切换到o3。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/obstacleDetection/mota_mismatches.png
	width 30text%
	groupId small

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
指定关联关系时需要考虑的因素。
\end_layout

\begin_layout Standard
位置误差应该有一个上限。当我们将
\begin_inset Formula $o_{i}$
\end_inset

和
\begin_inset Formula $h_{j}$
\end_inset

关联的时候，二者的距离如果小于某一个阀值，我们认为这是检测算法的位置误差。但是，当这个距离大于一个阀值的时候，我们就不应该这样认为，而是应该认为这是一个fals
e positive。这是由于实际物体都会具有一个尺寸，当上述距离超过物体的空间范围时，我们应该认为这是一个关联错误。
\end_layout

\begin_layout Standard
当发生mismatch错误时，只计入关联被错误切换的那帧，不计入后续的帧。例如，下图的case 1中，o1在t+2是被错误地关联到另外一个假设。在整个时间范围内
，只会将mismatch错误次数增加1，而不是将t+2之后的那些帧都记为mismatch错误，否则，无论case 1还是case 2，所得的mismatch错误
次数受时间范围的影响太大，并不能反映出关联错误的本质（case 1/2都只发生了一次关联错误）。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/obstacleDetection/mismatchingCounting.png
	width 30text%
	groupId small

\end_inset


\end_layout

\begin_layout Standard
详细的计算过程。参原论文2.1.3以及2.2。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Section
开源项目
\end_layout

\begin_layout Standard
https://github.com/mtbsteve/pegasus。无人机中使用ZED避障。2022年的，没有相关论文。大部分代码为python。提到了使用Z
ED-YOLO项目检测行人(https://github.com/stereolabs/zed-yolo，不过最新的YOLO原生支持ZED)。
\end_layout

\begin_layout Standard
https://github.com/Wingman-19/CPP_UAV_Stereo_Vision，CPP_UAV_Stereo_Vision
 ，一个机器人项目，在无人机中使用ZED避障。有2000行C++代码。给出的论文链接失效。
\end_layout

\begin_layout Standard
https://github.com/Weepingclown/obstacledetection，使用ZED检测障碍物。没有关联论文。
\end_layout

\begin_layout Standard
https://github.com/LucaRoma97/ZEDbot-robot-integration，使用ZED 2，Jetson，驱动一个3轮机器人寻找
充电桩。是一个硕士论文。代码只有200行左右。https://github.com/LucaRoma97/ZEDbot，是该工作的仿真部分。
\end_layout

\begin_layout Standard
https://github.com/kumarapurv/Object-Detection-and-Depth-Sensing-for-a-Small-Auto
nomous-Racecar-System，使用ZED以及Jetson开发一个赛车机器人，该项目只是其中的感知部分。代码只有100行左右。
\end_layout

\begin_layout Subsection
ASL的开源项目
\end_layout

\begin_layout Standard
我们需要学习@lsd-20的出品单位ASL的开源项目，因为@lsd-20的开发中可能会用到这些项目。
\end_layout

\begin_layout Standard
libnabo。https://github.com/ethz-asl/libnabo。实现K近邻搜索算法。使用C++模板实现，利用CPU执行计算。
\end_layout

\begin_layout Standard
一个类似的库是ANN，http://www.cs.umd.edu/~mount/ANN/。
\end_layout

\begin_layout Standard
K近邻搜索算法。https://en.wikipedia.org/wiki/Nearest_neighbor_search。问题本身的定义很简单：设在一个向量空间中
有一个点的集合S，指定其中一个点q，要求算法求出距离该点最近的一个或者K个点。一个最直接的算法是线性搜索：求取这个S中每个点距离q的距离，从中得到K近邻。但是，
当S比较大的时候，算法耗时较大。更高效的做法是提前对S进行一些分析处理，降低搜索阶段所要搜索的点的数目，提高算法性能。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
libpointmatcher。https://github.com/ethz-asl/libpointmatcher。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
集成到ROS中的模块。
\end_layout

\begin_layout Standard
ethzasl_ptam, a robustified and ROS-compatible version of PTAM（一个适用于单目相机的SLAM算法）
。
\end_layout

\begin_layout Section
实验数据集的选取
\end_layout

\begin_layout Subsection
选取标准
\end_layout

\begin_layout Enumerate
有双目相机的数据。除了一定会包含双目图像数据之外，最好有已经计算好的视差数据（disparity map）。由于本项目使用的ZED设备有内置的视差点云计算算法，
在部署阶段我们可以直接使用而不是使用自己的算法。如果数据集本身也含有视差数据，在开发阶段我们就不需要再实现这类算法。
\end_layout

\begin_layout Enumerate
有激光雷达采集的数据，这些数据可以作为基准真值。在ASL的工作中，这个基准真值的一个用途是用来评判两个基于双目图像的点云生成算法的优劣，本项目不需要这样做：我们
就默认使用ZED内置的算法，或者在将来选用更好的算法。在上述工作中，该数据的另外一个用途是，人工手工标注其中的物体的动态轨迹，用以判断该工作中物体动态轨迹求取算
法的性能。如果被选取的数据集中有上述标注最好，如果没有，我们可以手工标注。
\end_layout

\begin_layout Enumerate
能够估计移动设备位姿的数据。本项目并不需要能够在长时间（距离）中精确估计位姿，因为这个位姿信息只是被用来做3D物体跟踪，并不要求很精确。如果数据集中有IMU，则
这个问题比较容易解决。否则，就需要从激光雷达或者双目视差数据推算无人车位姿。后者这个思路虽然可行，但是会增加研发工作量。通过浏览论文@slo-21，对于机器人避
障任务，我们并不要求数据集中有GPS，虽然全局无人车导航需要这个信息。
\end_layout

\begin_layout Enumerate
对场景的要求：
\end_layout

\begin_deeper
\begin_layout Enumerate
目前只处理室外，不处理室内。
\end_layout

\begin_layout Enumerate
目标场景是社区内部。这类场景中包括机动车可以行驶的以及机动车不可行驶的。前者不能有红绿灯以及交通指示标志。后者指的是一些很狭窄或者有阻止机动车的路障的道路。
\end_layout

\begin_layout Enumerate
一些场景应该有行人、自行车、电动车。
\end_layout

\begin_layout Enumerate
需要考虑场景中的低纹理物体（比如墙面，纯色地面等）。
\end_layout

\begin_layout Enumerate
要求能够处理场景中有一般程度数量的活动物体（包括人），不要求处理拥挤情况（比如很多人、道路有交通堵塞）。
\end_layout

\begin_layout Enumerate
有尽量多的场景。
\end_layout

\end_deeper
\begin_layout Enumerate
对光线、气候等的要求：
\end_layout

\begin_deeper
\begin_layout Enumerate
能够处理强光（太阳直射），不要求处理弱光（无人车不会在夜晚行驶）。
\end_layout

\begin_layout Enumerate
能够处理晴天、多云、阴天，不要求处理雨天、下雪等气候。
\end_layout

\end_deeper
\begin_layout Enumerate
不需要考虑机动车行驶中的一些问题。本项目中的无人车不会在社区之外的公共道路行驶。即使在社区内的道路行驶时，也只会走人行道，不会进入到机动车道。一些供汽车自动驾驶
的数据集并不切合本项目任务。
\end_layout

\begin_layout Subsection
对相关数据集的调查
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
这个领域有多个相关数据集。从本项目的需求出发，我们调查了一些相关数据集，以下是相关信息。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
KITTI。优点：流行，用户多，有衍生数据集。
\end_layout

\begin_layout Standard
不满足点：场景是汽车自动驾驶中的市区，而不是社区。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
Malaga-urban Dataset。
\end_layout

\begin_layout Standard
不满足点：场景是汽车自动驾驶中的市区，而不是社区。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
Oxford RobotCar。其数据是对相同的场景的多次、长时记录，针对的一个问题是地点识别（place recognition），对本项目无益。高达20T的
数据处理起来反而是问题。
\end_layout

\begin_layout Standard
不满足点：场景是汽车自动驾驶中的市区，而不是社区。是在KITTI以及Cityscapes之后制作的。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
UASOL。
\end_layout

\begin_layout Standard
不满足点：（1）没有激光雷达数据，没有IMU部件。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
DrivingStereo。
\end_layout

\begin_layout Standard
不满足点：（1）场景是汽车自动驾驶中的市区，而不是社区。（2）没有GPS/IMU数据。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
对于场景是汽车自动驾驶中的市区（而不是社区）的数据集，图像从机动车道的角度采集的，大部分内容是行车道以及机动车。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
选择。截止到2022-9，我并没有找到非常理想的数据集，只能找次优的数据集。面向汽车自动驾驶的数据集多、质量好，我想应该是商业利益驱动的原因。
\end_layout

\begin_layout Section
KITTI
\end_layout

\begin_layout Subsection
概述
\end_layout

\begin_layout Standard
@vmr-13。针对移动机器人以及自动驾驶任务设计。包含德国的一些市区、乡村（rural）和高速公路等场景采集的真实图像数据。作者之一是丰田。http://ww
w.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=stereo。视角是行驶中的汽车。
\end_layout

\begin_layout Standard
录制时间。2011年11月26，28，29，30日，以及10月3日。
\end_layout

\begin_layout Standard
传感器。具有双目相机、激光雷达数据、GPS、IMU。使用了一个彩色双目相机，以及一个灰度双目相机，一共4个相机。每个双目相机中的两个相机的距离大约为54厘米。两
个双目相机的左侧的那两个相机的距离为6厘米，右侧也一样。我用的ZED的两个相机之间的距离为12厘米。似乎包含车子的精确位置的真值。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
激光雷达的基本参数：
\end_layout

\begin_layout Standard
- 旋转频率大约为每秒10圈。由于驱动旋转的是机械部件，无法做到精确的每秒10圈。转动一圈的耗时会在100毫秒附近波动。而另一方面，雷达的采样周期由于是电子驱动
的因而是很准确的。效果是，雷达没圈中收集到的点的数量会发生变化。
\end_layout

\begin_layout Standard
- 垂直方向的视野（field of view）为26.8°。这个角度看起来小，但是实际上能够满足自动驾驶领域的需求。
\end_layout

\begin_layout Standard
- 64线。这个挺厉害的。
\end_layout

\begin_layout Standard
- 最大测量距离120米。
\end_layout

\begin_layout Standard
对激光雷达的计时从其面向正后方开始（对应时间存放在timestamps_start.txt），50毫秒后转动到正前方（对应时间存放在times.txt），雷达有一个
设备能够检测到这个事件，从而触发两个双目相机的拍照操作，然后50毫秒后再转回正后方（对应时间存放在timestamps_end.txt）。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
场景。包含22个场景。每张图像中最多达15辆车和30个行人，还有各种程度的遮挡与截断。这些场景被分为City，Residential，Road，Campus，P
erson，其中的Campus，Residential以及Person类和本项目的符合。
\end_layout

\begin_layout Standard
GPS数据。即使在市区，GPS信号还是可以的，只有少量地区缺失。
\end_layout

\begin_layout Standard
容量。虽然这个数据库有180GB容量，但是其时间长度合计也只有6个小时，覆盖的场景显然不够全面。
\end_layout

\begin_layout Standard
可能的应用。可以被用在3D物体检测以及跟踪场合。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
局限性。
\end_layout

\begin_layout Enumerate
一般情况下的精度能够达到10厘米，但是在市区峡谷等GPS丢失区域，无法达到这个精度。
\end_layout

\begin_layout Enumerate
IMU数据和图像数据没有被同步（？）。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsection
相关数据集
\end_layout

\begin_layout Standard
KITTI-DEPTH。
\begin_inset space \space{}
\end_inset

是KITTI数据集的一个小子集，并没有包含所有立体图像的视差图。主要用做竞赛目的。
\end_layout

\begin_layout Standard
SemanticKITTI。KITTI数据集本身并没有包含语义标注。其他研究者提供了一些手工标注，参@aro-21，p.9。SemanticKITTI是这样的一个
数据集。
\end_layout

\begin_layout Subsection
相关竞赛
\end_layout

\begin_layout Standard
官方网站提交的作品中，有些有论文以及代码，有些没有。竞赛中用的数据集应该只是KITTI数据集的一部分。其中的开源作品有利于我们学习对应领域的技术，有些也许可以直
接被用在本项目中。
\end_layout

\begin_layout Standard
由于收集数据时采用了较多种传感器，所以该数据集可以被用在多个场合。官方设计了多个竞赛，每个竞赛包括竞赛规则，数据，而且，收录了很多参与者的代码以及结果。可能和本
项目相关的如下。
\end_layout

\begin_layout Standard
双目图像立体匹配（stereo）。
\end_layout

\begin_layout Standard
Optical Flow（光流）。
\end_layout

\begin_layout Standard
2D/3D目标检测（object detection）。
\end_layout

\begin_layout Standard
目标跟踪（tracking）。
\end_layout

\begin_layout Subsection
原始数据集
\end_layout

\begin_layout Standard
官方说明。官网https://www.cvlibs.net/datasets/kitti/raw_data.php中的“raw data development
 kit”中的readme.txt含有详细的说明。
\end_layout

\begin_layout Subsubsection
下载
\end_layout

\begin_layout Standard
该机构发布了多套数据集，其中的raw data部分被我们称为kitti原始数据集。这个部分只是总体驾驶录制的数据的1/4，其他的组成各种基准测试数据集。
\end_layout

\begin_layout Standard
访问http://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=stereo，账户信息：zh
angbo_nk@163.com/zbkitti。我只下载数据集中的以下部分：synced+rectified data，calibration以及trackle
ts，没有下载其: unsynced+unrectified data部分 。需要翻墙，因为数据存放在亚马逊云中。由于整个数据集中文件的数量太多，我采用脚本方式
批量下载它们。虽然官网提供了一个“raw dataset download script”，但是它并不适用于国内有墙的网络环境，也没有能够依据场景来存放下载的文
件。
\end_layout

\begin_layout Standard
对于我所使用的翻墙软件，下载速度可以达到1MB/s。由于整个数据集为180GB，估计的总下载时间为50小时（两天）。由于整个时间不是很长，而我的开发机（Asus
3）有翻墙能力，所以在这个机器上执行整个下载任务。
\end_layout

\begin_layout Standard
对于一个序列，对应的三个文件的URL形如：
\end_layout

\begin_layout Standard
https://s3.eu-central-1.amazonaws.com/avg-kitti/raw_data/2011_09_28_drive_0021/2011
_09_28_drive_0021_sync.zip
\end_layout

\begin_layout Standard
https://s3.eu-central-1.amazonaws.com/avg-kitti/raw_data/2011_09_26_calib.zip
\end_layout

\begin_layout Standard
https://s3.eu-central-1.amazonaws.com/avg-kitti/raw_data/2011_09_26_drive_0001/2011
_09_26_drive_0001_tracklets.zip
\end_layout

\begin_layout Standard
对于某个URL，下载命令如下：
\end_layout

\begin_layout Standard
wget -e use_proxy=yes -e https_proxy=127.0.0.1:7890 https://s3.eu-central-1.amazonaws.
com/avg-kitti/raw_data/2011_09_28_drive_0021/2011_09_28_drive_0021_sync.zip
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
我们编写了C++程序来完成上述任务。该程序位于/sw/obstacleAvoidance/cv/datasetConstruction/kitti/downlo
ading。由于所要下载的文件多、容量大，中途很可能会出现各种问题（翻墙账户流量耗尽等），我们采用多轮的思路。该程序的一次运行是一轮，一轮的目标是下载前一轮中没
有成功下载的文件。
\end_layout

\begin_layout Standard
我们依据网站中信息只做了一个场景/架次的列表文件（inputData/kittiDataDirectory.txt），该程序依据该列表文件下载所有数据。一些驾次有
tracklets的数据，有些没有，我们在该列表文件中有标注。
\end_layout

\begin_layout Standard
有个别驾次的数据（Campus/2011_09_28_drive_0047）没有成功地被自动下载，我手工下载。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
解压缩。下载的文件是zip格式的，需要被解压缩。由于文件数量多，我们并不是手工来执行这个任务，而是使用一个C++程序/sw/obstacleAvoidance/
cv/datasetConstruction/kitti/unzipFiles。
\end_layout

\begin_layout Standard
从kitti官网上下载的数据被存放在sw机器的/sw/cv/dbase/kittiRawZipped目录，解压缩后的数据放在该机器的/sw/cv/dbase/k
ittiRaw目录。
\end_layout

\begin_layout Subsubsection
数据目录结构
\end_layout

\begin_layout Standard
图像。从时间戳看，图像采样频率是10Hz，采样时间间隔是固定的。
\end_layout

\begin_layout Standard
数据容量。总共180G。
\end_layout

\begin_layout Standard
目录结构。官方给出了这些zip文件以及对应的子目录的目录结构的如下的示意图。这个图只是示意性质的，不能直接在每个zip文件所在的目录解压缩，否则不能形成下图的目
录结果。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/dataFormat.png
	width 50text%
	groupId half

\end_inset


\end_layout

\begin_layout Standard
解压缩并删除zip文件之后，形成的目录如下图。“#”之后的是我的注释。
\end_layout

\begin_layout Verbatim
-- City  # 场景名字
\end_layout

\begin_layout Verbatim
    `-- 2011_09_26   # 录制的日期
\end_layout

\begin_layout Verbatim
        |-- 2011_09_26_drive_0001_sync    # 一天会有多个驾次（drive），此处的0001是一次架次的标识
\end_layout

\begin_layout Verbatim
        |   |-- image_00                  # 图像采集设备00的数据
\end_layout

\begin_layout Verbatim
        |   |   |-- data
\end_layout

\begin_layout Verbatim
        |   |   |   |-- 0000000000.png    # 第0帧的图像
\end_layout

\begin_layout Verbatim
        |   |   |   |-- ......
\end_layout

\begin_layout Verbatim
        |   |   |   `-- 0000000107.png    # 第107帧的图像 
\end_layout

\begin_layout Verbatim
        |   |   `-- timestamps.txt
\end_layout

\begin_layout Verbatim
        |   |-- image_01                  # 图像采集设备01的数据，该目录的内部结果和00的相同。
\end_layout

\begin_layout Verbatim
        |   |-- 内容和iamge_00的类似
\end_layout

\begin_layout Verbatim
        |   |-- image_02                  # 图像采集设备02的数据，该目录的内部结果和00的相同。
\end_layout

\begin_layout Verbatim
        |   |-- 内容和iamge_00的类似
\end_layout

\begin_layout Verbatim
        |   |-- image_03                  # 图像采集设备03的数据，该目录的内部结果和00的相同。
\end_layout

\begin_layout Verbatim
        |   |-- 内容和iamge_00的类似        
\end_layout

\begin_layout Verbatim
        |   |-- oxts                      # ?
\end_layout

\begin_layout Verbatim
        |   |   |-- data
\end_layout

\begin_layout Verbatim
        |   |   |   |-- 0000000000.txt
\end_layout

\begin_layout Verbatim
        |   |   |   |-- ......
\end_layout

\begin_layout Verbatim
        |   |   |   `-- 0000000107.txt
\end_layout

\begin_layout Verbatim
        |   |   |-- dataformat.txt
\end_layout

\begin_layout Verbatim
        |   |   `-- timestamps.txt
\end_layout

\begin_layout Verbatim
        |   |-- tracklet_labels.xml       # ?
\end_layout

\begin_layout Verbatim
        |   `-- velodyne_points           # 激光雷达的点云数据，目录的名字来源于该设备的型号Velodyne
\end_layout

\begin_layout Verbatim
        |       |-- data
\end_layout

\begin_layout Verbatim
        |       |   |-- 0000000000.bin
\end_layout

\begin_layout Verbatim
        |       |   |-- ......
\end_layout

\begin_layout Verbatim
        |       |   `-- 0000000107.bin
\end_layout

\begin_layout Verbatim
        |       |-- timestamps.txt
\end_layout

\begin_layout Verbatim
        |       |-- timestamps_end.txt
\end_layout

\begin_layout Verbatim
        |       `-- timestamps_start.txt
\end_layout

\begin_layout Verbatim
        |-- calib_cam_to_cam.txt          # ?
\end_layout

\begin_layout Verbatim
        |-- calib_imu_to_velo.txt         # ?
\end_layout

\begin_layout Verbatim
        `-- calib_velo_to_cam.txt         # ?
\end_layout

\begin_layout Standard
代码中有些地方也将驾次称为sequence。
\end_layout

\begin_layout Subsubsection
数据集的统计信息
\end_layout

\begin_layout Standard
有149个驾次，容量为183 GB。
\end_layout

\begin_layout Standard
一共有47,494个帧对。依据图像采样频率10Hz计算，对应的时间长度只有1.3个小时。这个时间长度根本达不到产品部署的要求。
\end_layout

\begin_layout Subsubsection
操作该数据集的相关软件工具
\end_layout

\begin_layout Standard
https://github.com/ethz-asl/kitti_to_rosbag，将kitti数据转换为ros能够读取的格式。采用C++语言编写。该库只是读
取kitti中的数据（包括相机校准数据），并没有使用它们。
\end_layout

\begin_layout Standard
https://github.com/utiasSTARS/pykitti，是一个读取kitti数据的python实例程序。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
激光雷达点云数据
\end_layout

\begin_layout Standard
每个采样点的信息：空间点的坐标x,y,z，该点的反射率信息r（表示reflection），每个数是float类型。坐标的单位为米，坐标相对于激光雷达设备（而不是
数目相机）。每帧的数据文件的长度为1.8MB左右，含有0.12M次采样。文件的存放格式就是C++语言的float以二进制方式被直接写入到文件中。
\end_layout

\begin_layout Subsubsection
对齐与时间戳
\end_layout

\begin_layout Standard
整个系统以激光雷达为准进行时间对齐。将激光雷达从正后方开始，逆时针旋转一圈的时间范围称为一帧。
\end_layout

\begin_layout Standard
帧的序号始于0。比如，在一个相机采集的图像的图像的文件命名就是始于0。
\end_layout

\begin_layout Standard
各个传感器数据的同步。激光雷达和立体相机之间是通过硬件来完成同步的，而它们和惯导部件之间是通过时间戳信息在软件层面上完成同步的。具体地，在激光雷达的旋转部件上安
装了一个簧片触电（reed contact），每当雷达转动到正前方时，触发一个信息，进而触发双目相机拍照。和对惯导部件无法这样做，只能依据其数据的时间戳来对齐。
惯导部件的采样率为100Hz。对于每帧，寻找那个距离触发事件时间最近的，将其作为该帧的惯导部件的数据。
\end_layout

\begin_layout Standard
如前文所属，由于激光雷达旋转一圈的时间间隔不是固定的，会在100毫秒附近波动，因而帧的周期/频率也不是固定的。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
时间戳文件。各个传感器的数据目录下都含有一个文件timestamps.txt，记录该帧的时间。对于激光雷达，将转动部件面向正前方的那个时刻作为该帧的时间。同时，还
会记录该帧的起始以及终止时间，对应的文件是timestamps_start.txt以及timestamps_end.txt。一个驾次包括以下时间戳文件：
\end_layout

\begin_layout Verbatim
./image_00/timestamps.txt
\end_layout

\begin_layout Verbatim
./image_01/timestamps.txt
\end_layout

\begin_layout Verbatim
./image_02/timestamps.txt
\end_layout

\begin_layout Verbatim
./image_03/timestamps.txt
\end_layout

\begin_layout Verbatim
./oxts/timestamps.txt
\end_layout

\begin_layout Verbatim
./velodyne_points/timestamps.txt
\end_layout

\begin_layout Standard
该文件中时间的格式为：年-月-日 时:分:秒:纳秒，一个例子是2011-09-28 14:18:41.098502144。
\end_layout

\begin_layout Subsubsection
双目相机的数据
\end_layout

\begin_layout Standard
该数据集涉及两组双目相机，一个是灰度的，对应的数据位于image_00以及image_01，一个是彩色的，对应的数据位于image_02以及image_03。由
于我们的任务使用的ZED是彩色的，所以我们选择后者，也就是说，我们关注image_02/03，而不关注image_00/01。
\end_layout

\begin_layout Standard
图像中的引擎盖以及天空部分已经被裁剪，后续算法无需再做这个处理。
\end_layout

\begin_layout Standard
图像的分辨率。是1224 x 370。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
惯性导航传感器oxts的数据
\end_layout

\begin_layout Standard
目前我的工作还没有涉及到这方面，因而目前没有关注之。
\end_layout

\begin_layout Subsection
KITTI Stereo 2015数据集
\end_layout

\begin_layout Standard
KITTI官方发布了该数据集用于立体匹配应用。GwcNet的论文以及开源代码使用了该数据集。为了学习该软件的用法，我们需要使用该数据集。
\end_layout

\begin_layout Standard
下载。访问https://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=stereo，下载其
中的“Download stereo 2015/flow 2015/scene flow 2015 data set (2 GB)”以及“Download
 development kit (3 MB)”部分。该数据集被简称为“KITTI 2015”。
\end_layout

\begin_layout Subsection
深度真值数据集
\end_layout

\begin_layout Standard
MADNet的论文中给出了获得KITTI raw data对应的上述“真值”文件的一个文献@sic-17，后者是KITTI官方对该数据集中的激光雷达点云图进行处
理，得到的深度图的“真值”。由于这种方法是从稀疏的激光点云图推算出的深度，其中有些像素点出的值是估算得到，并不是传感器直接测量得到，因为不能算作真值。不过，这种
计算结果是目前的传感技术以及计算计算所能够得到的最好的结果，所以文献就将其称为真值。
\end_layout

\begin_layout Standard
KITTI官方给出了这些真值文件的下载链接，为https://www.cvlibs.net/datasets/kitti/eval_depth.php?benchma
rk=depth_completion。我下载了其中的“annotated depth maps data set”以及“development
 kit”，被放置到/sw/cv/dbase/kittiDepth目录，前者被放在子目录train以及val中，后者被放在子目录devkit中。下文将这个数据集
简称为KITTI数据集的“深度真值数据集”（kitti depth ground-truth dataset）。
\end_layout

\begin_layout Standard
图像分辨率。该数据集中图像的分辨率是1241 x 376，和双目相机的一致。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
数据解读。虽然数个数据集中的深度信息是以普通图像格式存放的，而且也能被图像查看软件查看，但是其中的数据并非普通图像文件中的那样。依据kittiDepth/dev
kit/readme.txt，深度图中的每个像素是一个uint16。当其为0时，表示对应没有对应深度值。否则，将其除以256.0，就得到以米为单位的深度。
\end_layout

\begin_layout Subsubsection
目录结构
\end_layout

\begin_layout Standard
本项目关系的是其子目录train以及val，它们的结构如下。
\end_layout

\begin_layout Verbatim
train
\end_layout

\begin_layout Verbatim
    2011_xx_xx_drive_xxxx_sync
\end_layout

\begin_layout Verbatim
        proj_depth
\end_layout

\begin_layout Verbatim
           groundtruth             # "groundtruth" describes our annotated
 depth maps
\end_layout

\begin_layout Verbatim
               image_02            # image_02 is the depth map for the left
 camera
\end_layout

\begin_layout Verbatim
                  0000000005.png   # image IDs start at 5 because we accumulate
 11 frames
\end_layout

\begin_layout Verbatim
                  ...
              # ..
 which is +-5 around the current frame
\end_layout

\begin_layout Verbatim
               image_03            # image_02 is the depth map for the right
 camera
\end_layout

\begin_layout Verbatim
                  0000000005.png
\end_layout

\begin_layout Verbatim
                  ...
           
\end_layout

\begin_layout Verbatim
    - another driveID
\end_layout

\begin_layout Verbatim
      ...
 
\end_layout

\begin_layout Verbatim
val
\end_layout

\begin_layout Verbatim
    (same as in train)
\end_layout

\begin_layout Section
3D处理库概述
\end_layout

\begin_layout Subsection
候选
\end_layout

\begin_layout Standard
Open3D。@oam-18。比pcl出现的晚些，但是目前的流行度二者差不多。强调代码质量，开发过程的规范，有尽量少的库依赖。追求易用性。只会加入那些经典的算法
，而不会为了追求全面而加入那些小众算法。论文@oam-18给出了完成一个功能的使用Open3D以及pcl的代码，前者明显要简洁。
\end_layout

\begin_layout Standard
cilantro。https://arxiv.org/abs/1807.00399。2018年出现的。美国Maryland大学的。
\begin_inset space \space{}
\end_inset

项目活跃度明显低于Open3D以及pcl。文档少。
\end_layout

\begin_layout Subsection
比较
\end_layout

\begin_layout Standard
OpenCV与pcl。
\end_layout

\begin_layout Standard
OpenCV偏重于2D图像处理（虽然目前也有部分3D处理功能，但是这方面的功能远弱于pcl），而pcl只处理三维的。例如，pcl居然
\end_layout

\begin_layout Standard
OpenCV历史更悠久（1999年发布），更成熟。而pcl发布于2010年，有的地方还不成熟。
\end_layout

\begin_layout Subsection
Open3D
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
C++ API文档。http://www.open3d.org/docs/release/cpp_api/index.html
\end_layout

\begin_layout Subsubsection
安装
\end_layout

\begin_layout Standard
软件源没有，需要自行构建。
\end_layout

\begin_layout Standard
== 目前还没有成功。
\end_layout

\begin_layout Standard
安装依赖的库。util/install_deps_ubuntu.sh
\end_layout

\begin_layout Standard
执行通常的cmake构建，运行cmake需要加的一个选项：-DBUILD_PYTHON_MODULE=OFF，以禁用构建Python API。
\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
代码。https://github.com/isl-org/Open3D。C++开发，使用C++11，cmake。
\end_layout

\begin_layout Standard
该库将point clouds, meshes, and RGB-D images当做不同的处理对象，提供了操作它们的API。
\end_layout

\begin_layout Standard
Python以及C++ API。依据https://forum.open3d.org/t/python-vs-c-api/84/3，该库本身的核心虽然是C++写的，
但是其文档侧重点是Python API。有网文说难以从官方文档中学习到所有C++ API的用法。目前不知道其Python API和C++ API是否提供相同功能
。
\end_layout

\begin_layout Standard
关于深度到点云的转换。http://www.open3d.org/docs/0.7.0/python_api/open3d.geometry.create_point_cl
oud_from_depth_image.html，是python API，尚不知道C++ API是否具有该功能。 
\end_layout

\begin_layout Subsection
cilantro
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
https://codedocs.xyz/kzampog/cilantro/。文档缺乏。
\end_layout

\begin_layout Subsubsection
安装
\end_layout

\begin_layout Standard
软件源没有，需要自行构建。
\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
https://github.com/kzampog/cilantro.
\end_layout

\begin_layout Section
opencv
\end_layout

\begin_layout Subsection
文献
\end_layout

\begin_layout Standard
文档。https://docs.opencv.org/4.x/
\end_layout

\begin_layout Standard
官网。https://opencv.org/。
\end_layout

\begin_layout Subsection
安装
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
https://docs.opencv.org/4.x/d7/d9f/tutorial_linux_install.html。官方给出的安装指南。
\end_layout

\begin_layout Standard
https://code.litomisky.com/2014/03/09/how-to-have-multiple-versions-of-the-same-li
brary-side-by-side/，如何在一个机器中安装多个版本的OpenCV。
\end_layout

\begin_layout Standard
https://stackoverflow.com/questions/45614230/running-multiple-versions-of-opencv-
on-the-same-computer
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
从软件源安装
\end_layout

\begin_layout Standard
并非操作系统桌面系统依赖的一个库，因而可以被自由的安装与卸载。
\begin_inset space \space{}
\end_inset

Mint 20.04软件源中有该库，名字为libopencv-dev，版本为4.2.0。可以直接安装。
\end_layout

\begin_layout Standard
核实版本。安装后，在头文件目录（/usr/include/opencv4/opencv2）下，搜索CV_VERSION，就可以看出其版本。
\end_layout

\begin_layout Subsubsection
自行构建
\end_layout

\begin_layout Standard
有的软件需要和该库的低版本链接。
\end_layout

\begin_layout Standard
下载。访问https://github.com/opencv/opencv，选择3.4版，下载。已经备份到/h/software/opencv。
\end_layout

\begin_layout Standard
规划。opencv和我的工作密切相关，将会被重度使用。不同的应用程序所使用的opencv库的版本可能会不同，我们应该在系统中安装多个版本的opencv。估计其他
用户也可能有这个需求，构建好之后的库应该被安装在系统的某个目录，而不是我个人目录。我们选择/usr/local/lib作为父目录，其下存放该库的多个版本。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
依赖。需要执行以下的命令以安装该库依赖的两个包：
\end_layout

\begin_layout Standard
sudo apt install libgtk2.0-dev 
\end_layout

\begin_layout Standard
sudo apt install pkg-config
\end_layout

\begin_layout Standard
否则，一些程序运行时会报以下的错误：
\end_layout

\begin_layout Standard
terminate called after throwing an instance of 'cv::Exception' what(): OpenCV(3.4.
18-dev) /home/zb/tem/opencv-3.4/modules/highgui/src/window.cpp:642: error:
 (-2:Unspecified error) The function is not implemented.
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
构建。总体上执行传统的cmake构建步骤，一些命令的细节如下。
\end_layout

\begin_layout Standard
cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lib/opencv3.4 ..
\end_layout

\begin_layout Standard
执行时报告下载一些软件失败，这是由于我的机器需要翻墙才能访问github。这个并不影响该库的后续构建。
\end_layout

\begin_layout Standard
最后执行sudo make install将该库安装到规划的那个目录。
\end_layout

\begin_layout Subsection
库接口文件
\end_layout

\begin_layout Subsubsection
从软件源安装的
\end_layout

\begin_layout Standard
头文件。位于/usr/include/opencv4，位于子目录opencv2下。
\end_layout

\begin_layout Standard
名字空间。cv。
\end_layout

\begin_layout Standard
库。位于/usr/lib/x86_64-linux-gnu。有一些以libopencv打头的文件。常用的库是opencv_core，opencv_imgproc
，opencv_highgui。其中和dnn相关的是opencv_dnn ，和目标检测相关的是opencv_dnn_objdetect。 
\end_layout

\begin_layout Subsubsection
自行构建的
\end_layout

\begin_layout Standard
头文件。位于/usr/include/opencv2。其中的opencv.hpp包含所有子模块的头文件。而目录usr/include/opencv似乎只有部分头文
件。
\end_layout

\begin_layout Standard
名字空间。cv。
\end_layout

\begin_layout Standard
库文件。位于/usr/lib/x86_64-linux-gnu。有一些以libopencv打头的文件。常用的库是opencv_core，opencv_imgpr
oc，opencv_highgui。
\end_layout

\begin_layout Subsection
概述
\end_layout

\begin_layout Standard
实现CV领域的常见操作。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
演化历史。有几个版本系列，低版本系列中的一些功能在高版本系列中反而会没有，这个和一般的版本更迭不同。总的思路是新增功能添加到新版本系列中，而老版本序列强调稳定性
而不是新功能。
\end_layout

\begin_layout Standard
1.x。起初是使用C而不是C++开发的，这个系列的后续版本部分使用C++。
\end_layout

\begin_layout Standard
2.x。尽量使用C++。其中的一个模块opencv_contrib用于放置尚未成熟的代码。opencv_gpu放置使用CUDA加速的OpenCV函数。有对Open
CL的支持。
\end_layout

\begin_layout Standard
3.x。不再支持C API。与2.x不兼容，这个系列中的大部分方法都使用OpenCL加速。opencv_contrib还增加了受版权保护的代码。opencv_dnn
被持续改进和扩充。
\end_layout

\begin_layout Standard
4.x。发布于2018年10月。这个系列包含了2.x的一些功能。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
模块。该库被划分为若干模块，以下是和我们相关的模块。
\end_layout

\begin_layout Standard
core。核心模块，主要是提供了表示多维数组的Mat类。
\end_layout

\begin_layout Standard
imgproc。图像处理。
\end_layout

\begin_layout Standard
features2d。二维图像特征。
\end_layout

\begin_layout Standard
calib3d。包括单目以及双目相机校准，
\begin_inset space \space{}
\end_inset

立体匹配等功能。
\end_layout

\begin_layout Standard
objdetect。目标检测。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
多线程支持。该库支持多线程，也就是说，一个类的多个实例，或者一个类的成员函数，可以在多线程环境中被使用。这点不容易。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
异常处理。该库在异常（比如一个优化算法无法收敛）时会抛出一个cv::Exception的异常，该类型是std::exception的子类，因而其他能够捕获后者的
代码能够捕捉到该库抛出的异常。
\end_layout

\begin_layout Subsection
基本类型
\end_layout

\begin_layout Subsubsection
常见的类型定义
\end_layout

\begin_layout Standard
typedef std::string cv::String
\end_layout

\begin_layout Subsubsection
Scalar<T>
\end_layout

\begin_layout Standard
表示一个具有4个分量的向量。在OpenCV中常被用来存放一个颜色值（比如RGBA格式的）。
\end_layout

\begin_layout Subsubsection
Rect<T>
\end_layout

\begin_layout Standard
表示一个矩形区域，该类型的x,y表示左上角的坐标（而不是矩形中心的）。
\end_layout

\begin_layout Standard
该类模板定义了一组对矩形操作的函数。以常用的Rect为例，一些如下。
\end_layout

\begin_layout Standard
Point tl()。返回左上角的坐标。
\end_layout

\begin_layout Standard
Point br()。返回右下角的坐标。
\end_layout

\begin_layout Standard
int area()。返回其面积。
\end_layout

\begin_layout Standard
bool contains(const Point&p)。是否包含指定的点。
\end_layout

\begin_layout Standard
一些自由函数如下。
\end_layout

\begin_layout Standard
Rect operator|(const Rect& a, const Rect& b)。求取两个矩形框的并。
\end_layout

\begin_layout Standard
Rect operator&(const Rect& a, const Rect& b)。求取两个矩形框的交。
\end_layout

\begin_layout Subsubsection
Vec<T, n>
\end_layout

\begin_layout Standard
表示一个像素的所有通道数据。T是分量的类型，n是通道数，一个例子是Vec<uchar,3>。定义了这种向量的常见操作。定义了常见的这种向量的类型别名以便于使用，
比如Vec3b表示Vec<uchar,3>。
\end_layout

\begin_layout Subsection
Mat
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
https://docs.opencv.org/4.2.0/d3/d63/classcv_1_1Mat.html
\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
和Eigen中的矩阵类型不同，OpenCV中的类Mat表示一个n维张量。该类型能够表示多种对象，包括实值或者复值的向量，灰度或者彩色2D图像，3D图像（体素形成
的卷），点云等。
\end_layout

\begin_layout Standard
术语。类Mat的名字具有误导性，它对应的中文名字被定为张量，而不是矩阵，因为矩阵一般是指二维张量。
\end_layout

\begin_layout Subsubsection
张量数据的存放格式
\end_layout

\begin_layout Standard
以3D图像的存放为例来说明OpenCV中张量数据的存放格式。3D图像被保存在一个维度为3的张量中，从高维到低维，各个维的名字依次为页，行，列。每个张量元素的坐标
是按照上述顺序指定的。内存中，先存放一个行的各个列的张量，之后可能会有一些填充字节，然后是下一行。若干行的数据存放完毕后，可能会有页内的填充字节，之后是下一页的
数据。
\end_layout

\begin_layout Standard
例如，对于二维彩色图像，如下图所示，每个像素的所有通道的数据连续存放，一行的所有列的数据连续存放。一行的尾部可能有一些填充字节，不过一般没有。下图显示的是RGB
彩色图像的数据存放格式，每个像素的3个通道的存放顺序是BGR（而不是RGB）。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/opencv_image_data_storage_format.png

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
张量元素类型
\end_layout

\begin_layout Standard
张量的每个元素中的每个分量的数据类型是在构建张量时指定的，而且，在运行阶段不可以更改。
\end_layout

\begin_layout Standard
该库没有使用C++模块机制来定义元素类型，而是使用两个位段构成的整数来表示。这样做的主要原因是便于该库和其他不具有模板机制的编程语言（比如matlab）的绑定。
这会使得该库所能表示的元素类型是有限、固定的。两个位段中，一个被用来表示通道数量，一个被用来表示每个通道中的分量的数据类型。例如，常见的RGB彩色图像的通道数量
为3，每个通道的分量是一个unsigned char。
\end_layout

\begin_layout Standard
该库约定通道数量的范围是1到CV_CN_MAX（值为512），通道分量的类型对应的枚举常量如下：
\end_layout

\begin_layout Standard
CV_8U/ CV_8S。8位有/无符号整数。
\end_layout

\begin_layout Standard
CV_16U/CV_16S。16位有/无符号整数。
\end_layout

\begin_layout Standard
CV_32S。32位有符号整数。
\end_layout

\begin_layout Standard
CV_32F。32位浮点数（半精度）。
\end_layout

\begin_layout Standard
CV_64F。 64位浮点数（全精度）。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该类的成员函数depth()以及channels()分别返回整数，表示上述两个位段的值。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
分量值的范围。当分量的位数较少时，计算结果容易出现越界的现象，该类提供了这种情形下的限定范围的函数。例如，如果分量类型为CV_U8，调用形式为saturate_
cast<uchar>，所做的操作是：I(x,y)=min(max(round(r),0),255)。
\end_layout

\begin_layout Subsubsection
基本信息
\end_layout

\begin_layout Standard
设有一个类型为Mat的对象M，描述其基本信息的数据成员如下。
\end_layout

\begin_layout Standard
-M.dims是一个整数，表示其维数。对于3D图像，这个量是3。
\end_layout

\begin_layout Standard
-M.size是一个一维数组，第i个元素表示该数组第i维的大小。对于3D图像，一个例子是（5, 100, 100），表示有5页，每页为100 x
 100的图像。
\end_layout

\begin_layout Standard
-M.step，是一个一维数组，第i个元素表示当张量索引的第i维增加1的时候，变换前后两个索引对应的张量元素在内存中的地址的相差量。由于这个一维数组中索引较小的元
素对应着多维张量中较高维，所以有M.step[i] >= M.step[i+1] * M.size[i+1]，之所以使用“>=”而不是“==”，是由于可能会有填充字节
。
\end_layout

\begin_layout Standard
-M.data，返回存放张量数据的内存块的地址。
\end_layout

\begin_layout Standard
-M.rows.
 图像的行数。
\end_layout

\begin_layout Standard
-M.cols.
 图像的列数。该类并没有对应的函数来返回上述两个量。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
基于上述记号，数据存放格式可以被精确地描述如下。给定张量元素的一个下标
\begin_inset Formula $(i_{0},...,i_{M.dims-1})$
\end_inset

，其中
\begin_inset Formula $0\le i_{k}\le M.size[k]$
\end_inset

，其对应张量元素在内存中的地址为：
\end_layout

\begin_layout Standard
\begin_inset Formula $addr(M_{i_{0},...,i_{M.dims-1}})=M.data+M.step[0]*i_{0}+M.step[1]*i_{1}+...+M.step[M.dims-1]*i_{M.dims-1}.$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
相关函数如下。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
size()。返回一个类型Size，表示其宽度以及高度。
\end_layout

\begin_layout Standard
size_t elemSize() const。以字节为单位，返回一个张量元素的长度。例如，如果张量元素类型为CV_16SC3，该函数返回6。
\end_layout

\begin_layout Standard
type()。返回一个整数值，表示张量元素的类型，比如CV_16SC3。
\end_layout

\begin_layout Standard
empty()。如果张量为空，返回真。
\end_layout

\begin_layout Subsubsection
张量的构造与初始化
\end_layout

\begin_layout Standard
以2D图像的构造为例，其构造或者初始化的方式为Mat(nrows, ncols, type[, fillValue]) 或者create(nrows,
 ncols, type) ，其中type表示前文所述的通道数量以及分量数据类型。该库定义了以下一组宏供用户使用：
\end_layout

\begin_layout Standard
- 如果通道数小于等于4，用户可以使用宏CV_8UC1...CV_64FC4。
\end_layout

\begin_layout Standard
- 否则，用户可以使用以下宏来构建这样的类型：CV_8UC(n) ...
 CV_64FC(n)，或者 CV_MAKETYPE(CV_8U, n) ...
 CV_MAKETYPE(CV_64F, n) 。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
一些例子如下：
\end_layout

\begin_layout Verbatim
// make a 7x7 complex matrix filled with 1+3j.
\end_layout

\begin_layout Verbatim
Mat M(7,7,CV_32FC2, Scalar(1,3));
\end_layout

\begin_layout Verbatim
// and now turn M to a 100x60 15-channel 8-bit matrix.
\end_layout

\begin_layout Verbatim
// The old content will be deallocated
\end_layout

\begin_layout Verbatim
M.create(100, 60, CV_8UC(15));
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
Mat mtx(3, 3, CV_32F); // make a 3x3 floating-point matrix
\end_layout

\begin_layout Verbatim
Mat cmtx(10, 1, CV_64FC2); // make a 10x1 2-channel floating-point
\end_layout

\begin_layout Verbatim
                           // matrix (10-element complex vector)
\end_layout

\begin_layout Verbatim
Mat img(Size(1920, 1080), CV_8UC3); // make a 3-channel (color) image
\end_layout

\begin_layout Verbatim
                                    // of 1920 columns and 1080 rows.
\end_layout

\begin_layout Verbatim
Mat grayscale(img.size(), CV_MAKETYPE(img.depth(), 1)); // make a 1-channel
 image of
\end_layout

\begin_layout Verbatim
                                                        // the same size
 and same
\end_layout

\begin_layout Verbatim
                                                        // channel type
 as img
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该库定义了一些元素值具有某种固定模式的常量，为Mat::zeros , Mat::ones , Mat::eye ，例如：
\end_layout

\begin_layout Standard
Mat E = Mat::eye(4, 4, CV_64F)。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
对于小图像，可以采用流输出符，例如：
\end_layout

\begin_layout Standard
Mat C = (Mat_<double>(3,3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该库的一些算法只支持上述类型的一个子集，例如人脸检测算法只能处理8位深度的灰度以及彩色图像。
\end_layout

\begin_layout Subsubsection
张量元素的访问与遍历
\end_layout

\begin_layout Standard
本节只讨论二维张量（矩阵）的数据的遍历。有以下几种方式。
\end_layout

\begin_layout Standard
1.
 通过物理指针访问。有以下几种方式：
\end_layout

\begin_layout Standard
（A）获得每行的地址，再逐列访问。类Mat提供了一组名字为ptr的函数以及函数模板，以获得指定行的数据的起始地址，几个函数例子如下：
\end_layout

\begin_layout Standard
uchar* Mat::ptr ( int row = 0 ) 。适用于分量类型为uchar的。返回指定行的数据的起始地址。
\end_layout

\begin_layout Standard
template<typename T >
\end_layout

\begin_layout Standard
T* Mat::ptr ( int row = 0 ) 。适用于分量类型为T的，此处的T是用户希望使用的类型，比如uint16_t，不要使用opencv中的诸如
CV_U16等，后者只是opencv库内部用来标识数据类型的标注位整数。返回指定行的数据的起始地址。
\end_layout

\begin_layout Standard
这种方式能够处理行尾填充字节的情形。
\end_layout

\begin_layout Standard
（B）直接获得指定行、列位置像素的数据的地址。类Mat提供了一组名字为ptr的函数以及函数模板，以获得指定行、列的数据的起始地址，几个函数例子如下：
\end_layout

\begin_layout Standard
uchar* Mat::ptr ( int row, int col ) 。适用于分量类型为uchar的。返回指定行、列的数据的起始地址。
\end_layout

\begin_layout Standard
template<typename T >
\end_layout

\begin_layout Standard
T* Mat::ptr ( int row, int col ) 。适用于分量类型为T的。返回指定行、列的数据的起始地址。
\end_layout

\begin_layout Standard
（C）获得数据区的首地址，手工计算每个像素的数据的位置。具体的，Mat::data()函数返回数据区的首地址，之后，用户手工推算每个像素的位置。这种情形下需要用
户考虑行末填充字节的问题。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
2.将图像看做像素的一维序列，使用遍历器。例如，对于一个RGB图像，遍历的代码如下。
\end_layout

\begin_layout Verbatim
    MatIterator_<Vec3b> it, end;
\end_layout

\begin_layout Verbatim
    for( it = I.begin<Vec3b>(), end = I.end<Vec3b>(); it != end; ++it)
\end_layout

\begin_layout Verbatim
    {
\end_layout

\begin_layout Verbatim
        (*it)[0] = table[(*it)[0]];
\end_layout

\begin_layout Verbatim
        (*it)[1] = table[(*it)[1]];
\end_layout

\begin_layout Verbatim
        (*it)[2] = table[(*it)[2]];
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Standard
这种方式已经考虑了行末填充字节的情形。代码不用考虑图像维数。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
3.
\begin_inset space \space{}
\end_inset

具有访问边界检测的方式。Mat提供了一个at<T>(int row, int col)的函数，返回指定行、列像素数据的引用，其中T表示像素数据的类型，含义参pt
r部分。而且，这种访问方式可以检测下标越界。一个例子：
\end_layout

\begin_layout Verbatim
    for( int i = 0; i < I.rows; ++i)
\end_layout

\begin_layout Verbatim
        for( int j = 0; j < I.cols; ++j )
\end_layout

\begin_layout Verbatim
            I.at<uchar>(i,j) = table[I.at<uchar>(i,j)];
\end_layout

\begin_layout Standard
这种方式虽然易用，但是性能较低（因为要做越界检查，而且每次都需要计算指定行、列这两维的像素数据的地址）。
\end_layout

\begin_layout Standard
注意，上述类型T一般应该和张量的分量的数据类型一致。不一致时，并不会有编译错，程序运行时会将张量数据解读为类型T。
\end_layout

\begin_layout Standard
4.
 如果张量是二维的，从一个Mat对象构建一个Eigen::Matrix对象，使用后者访问张量中的元素，访问形式更加简洁。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
小结。方式3简短。如果需要高性能，使用方式1.A。
\end_layout

\begin_layout Subsubsection
改变张量的逻辑形状
\end_layout

\begin_layout Standard
对于一个三维张量（width x height x channel），可以更改其逻辑的宽度以及高度，条件是新张量的元素个数（宽度x高度）和原来的必须相同。执行这
个操作的函数如下：
\end_layout

\begin_layout Standard
Mat reshape(int cn, int rows=0) const;
\end_layout

\begin_layout Subsubsection
引用计数
\end_layout

\begin_layout Standard
该库采用引用计数技术令若干个矩阵对象共享一份张量数据。具体地，当用户将一个张量对象赋值给另外一个时该库只会增加张量数据的引用计数，并不会新创建一个内存块来存放原
来的张量数据。当用户通过一个引用修改了张量数据时，其他引用也会看到这个修改。只有当张量数据的引用技术为0的时候它所占用的内存才会被释放。
\end_layout

\begin_layout Standard
这个机制也适用于从一个已经存在的图像对象创建一个表示其部分区域（Region of Interest，ROI）的另外一个图像对象。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该库提供了这些引用的管理，包括深度复制、解除引用等。常见的成员函数如下。
\end_layout

\begin_layout Standard
clone()。对当前对象进行深度复制。具体地，对该对象原来所引用的张量数据进行一个克隆，令该对象指向这个新的副本。
\end_layout

\begin_layout Standard
release()。解除当前对象对张量数据的引用。逻辑上，当前对象是一个空张量。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
以下是一个例子。
\end_layout

\begin_layout Verbatim
	// create a big 8Mb matrix
\end_layout

\begin_layout Verbatim
	Mat A(1000, 1000, CV_64F);
\end_layout

\begin_layout Verbatim
	// create another header for the same matrix;
\end_layout

\begin_layout Verbatim
	// this is an instant operation, regardless of the matrix size.
\end_layout

\begin_layout Verbatim
	Mat B = A;
\end_layout

\begin_layout Verbatim
	// create another header for the 3-rd row of A; no data is copied either
\end_layout

\begin_layout Verbatim
	Mat C = B.row(3);
\end_layout

\begin_layout Verbatim
	// now create a separate copy of the matrix
\end_layout

\begin_layout Verbatim
	Mat D = B.clone();
\end_layout

\begin_layout Verbatim
	// copy the 5-th row of B to C, that is, copy the 5-th row of A
\end_layout

\begin_layout Verbatim
	// to the 3-rd row of A.
\end_layout

\begin_layout Verbatim
	B.row(5).copyTo(C);
\end_layout

\begin_layout Verbatim
	// now let A and D share the data; after that the modified version
\end_layout

\begin_layout Verbatim
	// of A is still referenced by B and C.
\end_layout

\begin_layout Verbatim
	A = D;
\end_layout

\begin_layout Verbatim
	// now make B an empty matrix (which references no memory buffers),
\end_layout

\begin_layout Verbatim
	// but the modified version of A will still be referenced by C,
\end_layout

\begin_layout Verbatim
	// despite that C is just a single row of the original A
\end_layout

\begin_layout Verbatim
	B.release();
\end_layout

\begin_layout Verbatim
	// finally, make a full copy of C.
 As a result, the big modified
\end_layout

\begin_layout Verbatim
	// matrix will be deallocated, since it is not referenced by anyone
\end_layout

\begin_layout Verbatim
	C = C.clone();
\end_layout

\begin_layout Subsubsection
函数输出张量的内存分配
\end_layout

\begin_layout Standard
对于该库的大部分函数，如果它们的输出是一个张量对象，则函数执行时会依据实际所需，更改该对象所占内存的容量，以容纳函数的输出。这些对象一般是函数调用者定义的局部对
象，它们的内存管理会遵循上一节中的原则。
\end_layout

\begin_layout Subsubsection
块
\end_layout

\begin_layout Standard
row(i)。返回第i行。
\end_layout

\begin_layout Standard
Mat operator()(const Rect & roi) const。返回指定区域的一个多维张量。这个块只是对原有张量中的元素的引用，并不会执行深度复制
。
\end_layout

\begin_layout Subsubsection
文本格式输出
\end_layout

\begin_layout Standard
如果张量是二维的（是一个矩阵），该库支持将其输出到C++流，比如cout中。在调试阶段可以利用这个功能来浏览张量中的数据。
\end_layout

\begin_layout Subsubsection
和Eigen::Matrix的相互转换
\end_layout

\begin_layout Standard
头文件。本节中的函数的声明位于<opencv2/core/eigen.hpp>
\end_layout

\begin_layout Standard
OpenCV定义了一组张量到Eigen矩阵的转换函数模板，典型的一个是：
\end_layout

\begin_layout Standard
void cv2eigen(const Mat& src, Eigen::Matrix<_Tp, _rows, _cols, _options,
 _maxRows, _maxCols>& dst) 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
Eigen中的矩阵转换为OpenCV中张量：
\end_layout

\begin_layout Standard
void eigen2cv(const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows,
 _maxCols>& src, Mat& dst) 
\end_layout

\begin_layout Subsection
InputArray/OutputArray
\end_layout

\begin_layout Standard
类InputArray。为了使得该库的函数能够处理多种类型的输入，该库创建了类InputArray，并提供了一组接口，能够将多种其他类型对象，比如Mat，std
::vector<>, cv::Vec<>或者Scalar等，转换成该类型对象。这样，这些函数就能够接受多种类型的实参，便于用户使用。
\end_layout

\begin_layout Standard
类OutputArray。类似的，为了使得该库的函数能够输出到多种类型的对象，该库创建了该类，并提供了一组接口，能够将多种其他类型对象转换成该类型对象。这样，这
些函数就能够接受多种输出类型的实参，便于用户使用。
\end_layout

\begin_layout Subsection
图像处理
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
https://docs.opencv.org/4.x/d7/da8/tutorial_table_of_content_imgproc.html
\end_layout

\begin_layout Subsubsection
基本图形绘制
\end_layout

\begin_layout Standard
虽然opencv是一个计算机视觉库，但是它也提供了最基本的图形绘制函数。
\end_layout

\begin_layout Standard
在一个图像中绘制矩形框。有以下函数。
\end_layout

\begin_layout Standard
void rectangle(InputOutputArray img, Rect rec, const Scalar& color, int
 thickness = 1, int lineType = LINE_8, int shift = 0);
\end_layout

\begin_layout Standard
void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar&
 color, int thickness = 1, int lineType = LINE_8, int shift = 0);
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
在一个图像中绘制文字。是以下函数：
\end_layout

\begin_layout Verbatim
void putText(InputOutputArray img, const String& text, Point org,
\end_layout

\begin_layout Verbatim
             int fontFace, double fontScale, Scalar color,
\end_layout

\begin_layout Verbatim
             int thickness = 1, int lineType = LINE_8,
\end_layout

\begin_layout Verbatim
             bool bottomLeftOrigin = false );
\end_layout

\begin_layout Standard
大部分参数的含义从它们的名字就可以推断出来，另外一些参数的含义如下：
\end_layout

\begin_layout Standard
org。文本显示框的左下角的坐标。
\end_layout

\begin_layout Standard
fontFace。枚举类型HersheyFonts中定义的一组字体。
\end_layout

\begin_layout Standard
bottomLeftOrigin。确定参数org中y坐标的含义。如果为true，表示选择图像的左下角为坐标原点（y轴向上）。否则，选择图像的左上角为坐标原点（y
轴向下），这是常见的做法。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
绘制多个字符串时可能发生冲突，为了避免这点，可以调用以下函数，以获得一段文字被绘制时所占用的矩形框，这在避免
\end_layout

\begin_layout Standard
Size getTextSize(const String& text, int fontFace, double fontScale, int
 thickness, int* baseLine);
\end_layout

\begin_layout Standard
大部分参数的含义从它们的名字就可以推断出来，参数baseLine是一个输出参数，所指整数存放相对于被绘制的文字的最低端，那个baseline的垂直方向上的偏移量
。函数返回一个Size对象，其中存放着这个框的宽度以及高度。
\end_layout

\begin_layout Subsubsection
图像颜色空间变换
\end_layout

\begin_layout Standard
void cvtColor(InputArray src, OutputArray dst, int code, int dstCn=0)。从一个颜色空间变换到
另外一个。code表示所要执行的转换，dstCn表示目标图像的分量个数。如果为0, 该函数将从src以及code推断。对于彩色图像，opencv使用BGR顺序（
而不是RGB)顺序存放各分量的数值。因此，为了得到一个以RGB顺序存放的图像，应该执行调用cvtColor(src, dst, CV_BGR2RGBA)，其中的
A分量被设置为全不透明。
\end_layout

\begin_layout Subsubsection
图像I/O
\end_layout

\begin_layout Standard
该库在模块imgcodecs中在名字空间cv中提供了一组自由函数，实现图像对象的IO。常用的如下。
\end_layout

\begin_layout Standard
Mat imread(const string& filename, int flags=IMREAD_COLOR)。
\end_layout

\begin_layout Standard
从指定的文件中读取图像数据。如果读取失败（由于文件缺失、不支持的格式等原因），返回一个空图像对象（Mat::data=nullptr）。参数flags实际上属于
枚举类型ImreadModes，常见取值如下。
\end_layout

\begin_layout Standard
- IMREAD_UNCHANGED。不更改颜色空间、分量深度。
\end_layout

\begin_layout Standard
- IMREAD_GRAYSCALE。转换为灰度图像。
\end_layout

\begin_layout Standard
- IMREAD_COLOR。转换为BGR三通道彩色图像。这是该参数的默认取值。
\end_layout

\begin_layout Standard
- IMREAD_ANYCOLOR。读取时不做颜色空间转换。
\end_layout

\begin_layout Standard
- IMREAD_ANYDEPTH。读取时不做分量的位数的转换。如果没有这项，这个位数将被转换为8位。
\end_layout

\begin_layout Standard
该函数的一些行为如下。
\end_layout

\begin_layout Standard
- 依据文件内容而不是文件名来确定图像格式。
\end_layout

\begin_layout Standard
- 对于RGB图像，如前文所述，在内存中以BGR的方式保存数据。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
bool imwrite(const string& filename, InputArray img, const vector<int>&
 params=vector<int>() )。
\end_layout

\begin_layout Standard
图像文件的格式取决于filename中的扩展名。最后一个参数指定保存图像时的可选参数，是若干个（paramId, paramValue)组。例如，如果以jpg格
式存放，paramId是图像质量对应的id，而paramValue是一个介于0到100的数值。
\end_layout

\begin_layout Subsection
dnn模块
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
总体上，并没有清晰、系统介绍dnn模块的网文或者书籍，可能是由于这个话题只是太偏具体应用。
\end_layout

\begin_layout Standard
总体介绍的文献如下。
\end_layout

\begin_layout Standard
https://docs.opencv.org/4.x/d2/d58/tutorial_table_of_content_dnn.html，官方介绍dnn模块。
\end_layout

\begin_layout Standard
https://github.com/opencv/opencv/wiki/Deep-Learning-in-OpenCV。介绍如何使用dnn模块来执行多种计算机
视觉任务，比如目标检测、语义分割等。
\end_layout

\begin_layout Standard
https://docs.opencv.org/4.x/d0/db7/tutorial_js_table_of_contents_dnn.html，官方的一些样例。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
和本项目的目标检测密切相关的一些文献如下。
\end_layout

\begin_layout Standard
https://docs.opencv.org/4.x/d4/db9/samples_2dnn_2object_detection_8cpp-example.html。
官方的，如何使用dnn模块来执行目标检测。代码虽然长，但是考虑了更多的情形。用户应该仔细学习这个样例。
\end_layout

\begin_layout Standard
https://learnopencv.com/deep-learning-with-opencvs-dnn-module-a-definitive-guide/
，介绍如何使用dnn模块来执行目标检测。含有Python以及C++的演示代码。
\end_layout

\begin_layout Standard
https://gist.github.com/YashasSamaga/e2b19a6807a13046e399f4bc3cca3a49#file-yolov4_
opencv_dnn_cuda-cpp
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
该模块只含有神经网络推理的功能，并不含有训练相关的功能。该模块的优势是，针对图像以及视频应用场景，优化推理速度。其推理速度在大部分情况下好于其他神经网络计算框架
比如Tensorflow等。因而，它适于在边缘设备中部署深度学习算法。实现了多个CV任务，包括人员检测、人体姿态估计等。
\end_layout

\begin_layout Standard
对常见的CV任务，该模块支持读入一些经典的预训练模型。以下是和本项目相关的一些信息：
\end_layout

\begin_layout Standard
目标检测。MobileNet SSD，VGG SSD，Faster R-CNN， EfficientDet。
\end_layout

\begin_layout Standard
图像分割。DeepLab，UNet，FCN。
\end_layout

\begin_layout Subsubsection
dnn模块体系结构
\end_layout

\begin_layout Standard
该模块中部分类以及它们的关系如下。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/opencv_dnn_classes.png

\end_inset


\end_layout

\begin_layout Standard
类LayerParams。表示构建（或者说初始化）一个网络层所需要的所有参数，包括以下几个部分：
\end_layout

\begin_layout Standard
1.
 通过基类Dict提供的一组标量参数。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

通过成员vector<Mat>提供的可训练的网络参数。
\end_layout

\begin_layout Standard
3.
 网络的原信息，包括该层实例的名字以及类型。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
类Layer。表示网络的一个层。派生类应该重载其forward()函数以实现前向推理。
\end_layout

\begin_layout Standard
类Net。表示一个神经网络。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
读取预训练模型
\end_layout

\begin_layout Standard
本模块能够读取几个不同学习框架生成的预训练模型，以下是这方面的一些信息。
\end_layout

\begin_layout Paragraph
Caffe
\end_layout

\begin_layout Standard
一个预训练模型对应两个文件：一个的扩展名为.prototxt，其内容为神经网络的拓扑结构，是纯文本格式。另外一个的扩展名为.caffemodel，其内容为神经网络的
权值。
\end_layout

\begin_layout Standard
相关函数如下。
\end_layout

\begin_layout Standard
Net readNetFromCaffe(const String &prototxt, const String &caffeModel =
 String());
\end_layout

\begin_layout Paragraph
Torch以及PyTorch
\end_layout

\begin_layout Standard
对于较老版本Torch生成的模型文件，dnn模块可以读取。对于最新版本的，模型文件需要被转换为ONNX格式，然后才能被读取。后面这种方法也适用于其他框架生成的模
型文件。
\end_layout

\begin_layout Paragraph
TensorFlow
\end_layout

\begin_layout Standard
一个预训练模型对应两个文件：一个扩展名为.pb，是二进制的protobuf格式，其内容为神经网络的权值，另外一个的扩展名为.pbtxt，是文本形式的protbuf格
式，其内容为神经网络的拓扑结构。
\end_layout

\begin_layout Subsubsection
类Layer
\end_layout

\begin_layout Standard
void setParamsFrom(const LayerParams &params);
\end_layout

\begin_layout Standard
头文件的注释支持，该函数只能将参数params中的以下内容复制到当前层中：层的可训练参数，层实例的名字以及类型。不能修改当前层的那些从Dict继承的标量参数。这
意味着，一旦一个网络被构建完毕，这些标量参数是无法修改的。
\end_layout

\begin_layout Subsubsection
类Net
\end_layout

\begin_layout Paragraph
网络构建
\end_layout

\begin_layout Standard
类Net的和网络构建相关的一些成员函数如下。
\end_layout

\begin_layout Standard
void setParam(LayerId layer, int numParam, const Mat &blob)。设置一个网络层的训练所得的权值。
\end_layout

\begin_layout Paragraph
设置计算设备
\end_layout

\begin_layout Standard
类Net的和设置计算设备相关的一些成员函数如下。
\end_layout

\begin_layout Standard
void setPreferableBackend(int backendId);
\end_layout

\begin_layout Standard
设置驱动计算设备的高层API的类别。可能的取值如下。
\end_layout

\begin_layout Standard
DNN_BACKEND_INFERENCE_ENGINE。如果构建OpenCV是利用了Intel的Inference Engine，可以选用这个。这种情形下它也
是默认选项。
\end_layout

\begin_layout Standard
DNN_BACKEND_OPENCV。
\end_layout

\begin_layout Standard
DNN_BACKEND_CUDA。
\end_layout

\begin_layout Standard
DNN_BACKEND_VKCOM。后端为Vulkan（一种针对图形、图像处理的、类似于OpenCL那样能够驱动多种类型设备的语言）。
\end_layout

\begin_layout Standard
DNN_BACKEND_HALIDE。后端为HALIDE（一种针对C++语言的嵌入式语言）。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
void setPreferableTarget(int targetId);
\end_layout

\begin_layout Standard
设置驱动计算设备的底层API的类别。可能的取值如下表最左列。OpenCV支持的高层API（后端）和这些底层API（目标）的组合如该表所示。
\end_layout

\begin_layout Verbatim
|                        | OPENCV | INFERENCE_ENGINE | HALIDE |  CUDA |
\end_layout

\begin_layout Verbatim
|------------------------|--------|------------------|--------|-------|
\end_layout

\begin_layout Verbatim
| DNN_TARGET_CPU         |      + |                + |      + |       |
\end_layout

\begin_layout Verbatim
| DNN_TARGET_OPENCL      |      + |                + |      + |       |
\end_layout

\begin_layout Verbatim
| DNN_TARGET_OPENCL_FP16 |      + |                + |        |       |
\end_layout

\begin_layout Verbatim
| DNN_TARGET_MYRIAD      |        |                + |        |       |
\end_layout

\begin_layout Verbatim
| DNN_TARGET_FPGA        |        |                + |        |       |
\end_layout

\begin_layout Verbatim
| DNN_TARGET_CUDA        |        |                  |        |     + |
\end_layout

\begin_layout Verbatim
| DNN_TARGET_CUDA_FP16   |        |                  |        |     + |
\end_layout

\begin_layout Standard
其中的DNN_TARGET_MYRIAD指的是Intel的movidius myriad VPU（vision processing unit），细节参http
s://www.intel.com/content/www/us/en/products/details/processors/movidius-vpu/movid
ius-myriad-x/products.html。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
获得网络信息
\end_layout

\begin_layout Standard
类Net的获得网络基本信息的一些成员函数如下。
\end_layout

\begin_layout Standard
vector<int> getUnconnectedOutLayers()。返回那些具有未连接输出的网络层的标识。这些层一般是神经网络的输出层。后者可以只包含一
部分，也可以具有几个部分（比如SSD）。
\end_layout

\begin_layout Standard
vector<String> getUnconnectedOutLayersNames()。返回那些具有未连接输出的网络层的名字。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
Ptr<Layer> getLayer(LayerId layerId)。给定一个层的ID，返回指定层。
\end_layout

\begin_layout Paragraph
设置输入
\end_layout

\begin_layout Standard
类Net的设置网络输入的一些成员函数如下。
\end_layout

\begin_layout Standard
void setInput(InputArray blob, const String& name = "", double scalefactor
 = 1.0, const Scalar& mean = Scalar());
\end_layout

\begin_layout Standard
可选参数name表示输入层的名字。可选参数scalefactor/mean指定如何对输入执行规整。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
前向计算
\end_layout

\begin_layout Standard
类Net的执行前向计算的一些成员函数如下。
\end_layout

\begin_layout Standard
Mat forward(const String& outputName = String());
\end_layout

\begin_layout Standard
执行前向计算，以得到指定名字的层（或者其部分）的输出，返回这个部分的输出。如果outputName为空字符串，这个操作被施加到整个网络。
\end_layout

\begin_layout Standard
void forward(OutputArrayOfArrays outputBlobs, const String& outputName =
 String());
\end_layout

\begin_layout Standard
和上面的函数类似。
\end_layout

\begin_layout Standard
void forward(OutputArrayOfArrays outputBlobs, const std::vector<String>&
 outBlobNames);
\end_layout

\begin_layout Standard
执行前向计算，以得到指定名字的若干层（或者其部分）的输出，存放在outputBlobs中。
\end_layout

\begin_layout Subsubsection
图像预处理
\end_layout

\begin_layout Standard
输入图像需要经过一个预处理，以符合深度网络的要求。OpenCV提供了以下函数来执行这个操作：
\end_layout

\begin_layout Verbatim
Mat blobFromImage(InputArray image, double scalefactor=1.0, const Size& size
 = Size(),
\end_layout

\begin_layout Verbatim
                  const Scalar& mean = Scalar(), bool swapRB=false, bool
 crop=false,
\end_layout

\begin_layout Verbatim
                  int ddepth=CV_32F);
\end_layout

\begin_layout Standard
各个参数的含义如下。
\end_layout

\begin_layout Standard
image。可以是使用opencv的imread()函数从一个图像文件中读取的图像数据，此时实参的类型为Mat。对于彩色图像，在内存中以BGR格式存放。
\end_layout

\begin_layout Standard
mean/scalefactor。如同一般的，目标检测领域的一些预训练模型要求输入层的每个输入分量的均值为0、方差为1。对于RGB图像中的每个像素，这需要将每个
分量减去127.5，再除以127.5（等价于乘以0.007843）。参数mean一般取（127.5，127.5，127.5），而scalefactor为0.007843。
\end_layout

\begin_layout Standard
size。输出图像的尺寸。这个应该和预训练模型的要求一致。例如，对于MobileNet-SSD，为300 x 300。
\end_layout

\begin_layout Standard
swapRB。如果输入图像是通过调用opencv的imread()函数获得的，由于其存放格式是BGR，这个参数应该被设置为true，以得到RGB格式的图像数据。
\end_layout

\begin_layout Standard
crop。如果该参数为false（默认取值），输入图像被规整为预期的输出size，不执行裁剪，但是纵横比可能会变化。而当该参数为true时，调整图像尺寸，以使得
它的一边被规整为该边预期大小，另外一边大于等于该边预期大小。然后，以原图像中心为中心，执行裁剪，以得到预期尺寸，同时，输出图像的纵横比和原图像的一致。
\end_layout

\begin_layout Subsubsection
NMS函数
\end_layout

\begin_layout Standard
OpenCV有几个执行NMS的函数，其中一个的原型如下：
\end_layout

\begin_layout Verbatim
void NMSBoxes(const std::vector<Rect>& bboxes, const std::vector<float>&
 scores, 
\end_layout

\begin_layout Verbatim
              const float score_threshold, const float nms_threshold, 
\end_layout

\begin_layout Verbatim
              std::vector<int>& indices, 
\end_layout

\begin_layout Verbatim
              const float eta = 1.f, const int top_k = 0);
\end_layout

\begin_layout Standard
各个参数的含义如下。
\end_layout

\begin_layout Standard
bboxes。存放若干个边框的信息。
\end_layout

\begin_layout Standard
scores。存放这些边框对应的置信度。
\end_layout

\begin_layout Standard
score_threshold。只有置信度找过这个阀值的边框才可能被保留。
\end_layout

\begin_layout Standard
nms_threshold。NMS算法中那个IoU阀值。
\end_layout

\begin_layout Standard
indices。将被保留的边框在bboxes/scores中的索引。
\end_layout

\begin_layout Standard
eta。目前尚不知道这个参数有何用。
\end_layout

\begin_layout Standard
top_k。输出中最多保留top_k个边框。
\end_layout

\begin_layout Subsection
dnn中的目标检测
\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
OpenCV 4.x有以下两种执行目标检测的方式：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

使用深度网络（比如SSD等）。这种方式的属于opencv的dnn模块，该模块的源代码位于modules/dnn目录。OpenCV库提供了以下两个层面的API：
\end_layout

\begin_layout Standard
A.
\begin_inset space \space{}
\end_inset

高层面的类DetectionModel。给定一个输入图像以及一个预训练模型，该类试图封装所有操作，给用户呈现一个简单的API接口以执行目标检测。然而，OpenC
V对该类的用法说明的不详细，我在网上也没有找到更详细资料，实验中没有成功处理https://github.com/djmv/MobilNet_SSD_opencv
中的样例图像，所以目前没有采取这种方法。
\end_layout

\begin_layout Standard
B.低层面的，用户需要手工执行图像尺寸规整、驱动网络前向计算等操作。虽然这种方式稍微有些繁琐，但是OpenCV官方以及网上有较多的参考资料。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

使用传统方法。这种方式的属于opencv的objdetection模块，该模块的源代码位于modules/objdetect目录。原创论文是@rodua-01。
这个工作是2001年的，没有用到神经网络，使用的是传统方式。这类方法针对的任务是检测特定的一个目标类（比如人脸、车辆）而不是很多目标类。针对特点的目标类，找到该
目标类的特征。之后，逐个处理图像中的各个区域，将每个区域送往一个级联起来的、从粗粒度到细粒度的分类器，以判别当前区域中是否含有目标类。这种方法的优点是速度非常快
。但是，尚不知道现在这种方法的检测性能是否能够达到基于深度网络的。相关的文献可以从https://github.com/SvHey/thesis下载，其中原创性的
为@rodua-01。
\end_layout

\begin_layout Standard
我们采用的是1B。
\end_layout

\begin_layout Subsubsection
基于深度网络/类DetectionModel
\end_layout

\begin_layout Standard
文献。关于该类，OpenCV的文档（https://docs.opencv.org/4.x/d3/df1/classcv_1_1dnn_1_1DetectionMod
el.html#details）介绍地不详细。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
构造函数。DetectionModel(const String & model, const String & config = "" ) 。
\end_layout

\begin_layout Standard
从指定名字的两个文件中分别读取模型的参数、原型，构建检测网络。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
配置。DetectionModel& setNmsAcrossClasses (bool value) 
\end_layout

\begin_layout Standard
如果参数为false（这也是该类的默认情形），执行目标检测中的那个非最大抑制（NMS）时，是逐个目标类进行的。也就是，先对检测结果为第一个类的那些候选框做这个操
作，然后在针对接下来的一个目标类，依次类推。而如果该参数为true，则对检测结果中所有的候选框一次性的执行这个操作。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
检测。
\end_layout

\begin_layout Verbatim
void detect(InputArray frame, 
\end_layout

\begin_layout Verbatim
			vector<int> & classIds, vector<float>& confidences, vector<Rect> & boxes,
 
\end_layout

\begin_layout Verbatim
            float confThreshold=0.5f, float nmsThreshold=0.0f) 
\end_layout

\begin_layout Standard
各个参数的说明如下。
\end_layout

\begin_layout Standard
frame。存放被处理的输入图像。
\end_layout

\begin_layout Standard
nmsThreshold。网上的资料少，其含义需要进一步研究（一个相关的线索是该类的源代码，为modules/dnn/src/model.cpp）。
\end_layout

\begin_layout Section
点云图相关工具
\end_layout

\begin_layout Subsection
pcl-tools
\end_layout

\begin_layout Standard
和pcl库相关的一些工具（是应用程序，比如png2pcd）。软件源有，同名。安装后位于/usr/bin/目录，所有程序的名字以pcl_打头。
\end_layout

\begin_layout Standard
pcl_viewer。和用户交互的快捷键如下。
\end_layout

\begin_layout Standard
s。显示各个坐标轴的比例尺（scale）。
\end_layout

\begin_layout Standard
r。重置（reset）比例尺。
\end_layout

\begin_layout Standard
o。在perspective/parallel射影模式之间切换。
\end_layout

\begin_layout Standard
pcl_pcd_image_viewer。
\end_layout

\begin_layout Subsection
点云图可视化工具
\end_layout

\begin_layout Standard
文献。https://www.usna.edu/Users/oceano/pguth/md_help/html/other_point_cloud_viewers.h
tm
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
CloudCompare。参下。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
displaz。https://c42f.github.io/displaz/。安装官网给出的步骤就可以构建成功该软件。该软件支持ply格式但不支持pcd格式。只能
以黑白方式显示点云图（虽然官网宣称该软件有一个color模式）。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
pcl_viewer。不能显示点的坐标信息，我觉得其功能不够强大，以下是其他工具。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
SPDlib。http://www.spdlib.org/doku.php。软件源没有，需要自行构建。依据http://www.spdlib.org/doku.php?id
=spdlib:general:installation:installation，该库依赖多个其他库，估计构建起来麻烦。支持的部分格式：las。
\end_layout

\begin_layout Standard
lag。http://arsf.github.io/lag/。只支持它自己的格式以及ASCII格式。软件源没有，需要自行构建，依赖库laslib。
\end_layout

\begin_layout Standard
OPALS。https://opals.geo.tuwien.ac.at/html/stable/index.html。骨头三维扫描数据的可视化。
\end_layout

\begin_layout Standard
PointVue。只支持Windows。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
pointcloud-viewer。https://github.com/cgtuebingen/pointcloud-viewer。不怎么活跃。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
以下是GIS相关的一些工具。
\end_layout

\begin_layout Standard
grass。软件源有grass-gui（一个使用python编写的GUI工具），grass-dev，libgdal-grass，qgis-plugin-gras
s。但是依据https://grasswiki.osgeo.org/wiki/Processing_lidar_and_UAV_point_clouds_in_GR
ASS_GIS_(workshop_at_FOSS4G_Boston_2017)，该软件是一个GIS工具。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
qgis。https://www.qgis.org/en/site/。是一个地理信息系统中的工具。Mint 20.04软件源有该软件。
\end_layout

\begin_layout Subsection
CloudCompare
\end_layout

\begin_layout Standard
官网。https://www.cloudcompare.org/main.html。
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
https://www.danielgm.net/cc/，ccViewer的用法。
\end_layout

\begin_layout Subsubsection
安装
\end_layout

\begin_layout Standard
CloudCompare有多种安装方法，为了找到一个最好用的版本，我曾试过以下的安装方法，目前选用的是方法A。
\end_layout

\begin_layout Standard
A.从软件源安装。Mint 20.04的软件源有该软件，名字为cloudcompare。
\end_layout

\begin_layout Standard
ccViewer的版本为3.18。
\end_layout

\begin_layout Standard
问题。不支持pcd格式，虽然官网宣称支持。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
B.自行构建。该软件包依赖多个第三方插件，应该使用git clone，以获得包括这些插件的源代码。由于国内访问github不稳当，我租用了国外VPS，下载后传输到
国内。下载之后的软件包存档在/h/software/cloudCompare。该软件依赖的Qt版本是：5.12 <= Qt < 6.0。使用通常的cmake构建过程
即可构建、安装该软件。
\end_layout

\begin_layout Standard
ccViewer的版本为1.41.apha。
\end_layout

\begin_layout Standard
问题。不支持pcd格式。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
C.snap方式安装。官网虽然给出的是flatpak方式，但是在张波的机器上使用flatpak时，网络速度慢，而安装该软件需要大容量数据的传输。张波后来使用sna
p方式安装成功，安装命令为：
\end_layout

\begin_layout Standard
sudo snap install cloudcompare
\end_layout

\begin_layout Standard
安装成功后，使用以下命令运行cloudCompare或者ccViewer
\end_layout

\begin_layout Standard
snap run cloudcompare.CloudCompare
\end_layout

\begin_layout Standard
snap run cloudcompare.ccViewer $PWD/frame_99.pcd
\end_layout

\begin_layout Standard
ccViewer的版本为3.19，能打开PCD文件，但是需要在本地运行才可能，不能在sw机器上远程运行该软件，我估计是由于snap运行这种GUI程序时，没有考虑到
这种远程运行方式。
\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
应该可以被用来显示pcl库中点的类型为PointXYZRGBA的点云，目前尚未探索这点。
\end_layout

\begin_layout Subsubsection
显示点之间距离等信息
\end_layout

\begin_layout Standard
执行菜单命令Tools/Point Picking，弹出的一个工具条中，有几个命令能够显示点之间距离等信息。
\end_layout

\begin_layout Subsection
ccViewer
\end_layout

\begin_layout Subsubsection
安装
\end_layout

\begin_layout Standard
ccViewer是CloudCompare的一部分，并不是一个独立的软件包，需要随着后者的安装而安装。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
指定输入文件
\end_layout

\begin_layout Standard
GUI界面连“打开文件”的菜单项都没有，只允许用户拖动文件到该软件。启动该程序时可以指定被显示文件，但是必须使用绝对路径，不支持相对路径。可以使用$PWD来表示
之，例如：ccViewer $PWD/someFilename.ply。
\end_layout

\begin_layout Standard
支持的格式。依据https://www.cloudcompare.org/doc/wiki/index.php/FILE_I/O，该工具宣称支持PCD等很多格式。但是
，如前文所示，g该软件的一些版本并不支持。对于这种情形，可以ply或者vtk格式。虽然ccViewer打开这种转换之后的文件会报告一些问题，但是总体上可以被显示
。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
点的坐标
\end_layout

\begin_layout Standard
显示。在一个点上Shift+Left_Click，在弹出的界面中选择Yes，显示一个点的坐标。此处，该软件有一个小bug：坐标信息并不会立即被显示，而是需要用户
执行一个点云图操作（比如移动）。用户可以点击那个信息显示小窗口，移动其位置。
\end_layout

\begin_layout Standard
删除。在被显示的坐标上左键选中，然后按Delete键。
\end_layout

\begin_layout Subsection
点云格式转换
\end_layout

\begin_layout Standard
包pcl-tools提供了以下转换工具。
\end_layout

\begin_layout Standard
pcl_pcd2ply。
\end_layout

\begin_layout Standard
pcl_pcd2png。
\end_layout

\begin_layout Standard
pcl_pcd2vtk。
\end_layout

\begin_layout Standard
pdal。https://pdal.io/en/latest/。Mint 20.04软件源有该软件，包的名字是libpdal-dev。该软件是一个C++库，负责各种
点云图格式的转换。
\end_layout

\begin_layout Section
pcl库
\end_layout

\begin_layout Subsection
文献
\end_layout

\begin_layout Standard
https://en.wikipedia.org/wiki/Point_Cloud_Library，该库的总体介绍。
\end_layout

\begin_layout Standard
https://pointclouds.org/documentation/，官方文档。写的还不错，就是内容多，有时不容易找到感兴趣的部分。
\end_layout

\begin_layout Standard
https://pcl.readthedocs.io/projects/tutorials/en/master/。有一系列的导论网文。
\end_layout

\begin_layout Subsection
安装
\end_layout

\begin_layout Subsubsection
依赖
\end_layout

\begin_layout Standard
该库依赖多个第三方库，部分为Eigen，VTK（用在点云图的可视化中），FLANN（k-近邻搜索）。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
关于对VTK的依赖。只有当应用程序为了执行GUI操作而调用了和GUI相关的函数时才需要和VTK链接。因此，我们可以选择该库的一种简单的使用方式：只使用该库和GU
I无关的那些功能，处理数据，生成点云图文件。当然，如果用户一定要在程序中使用VTK库，其相关信息如下。
\end_layout

\begin_layout Standard
安装。Mint 20.04的软件源有，名字为libvtk7-dev。
\end_layout

\begin_layout Standard
头文件。/usr/include/vtk-7.1/
\end_layout

\begin_layout Standard
库。/usr/lib/x86_64-linux-gnu/，一组libvtk打头的库。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
从软件源安装
\end_layout

\begin_layout Standard
软件源有该库，名字为libpcl-dev。
\begin_inset space \space{}
\end_inset

在Mint 20.04中的版本为1.10.0，当前最新稳定版本为1.13.0，发布于2022年底。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
相关工具。Mint 20.04软件源中有一个包pcl-tools，会随着该库的安装而被安装，位于/usr/bin，是一组以pcl_打头的程序。其中，程序pcl_v
iewer可以显示PCD文件。
\end_layout

\begin_layout Subsubsection
自行构建
\end_layout

\begin_layout Standard
从Mint 20.04软件源安装的pcl库在使用中遇到了以下问题：基于该库生成的ply文件被ccViewer读取时报告一些错误；基于该库的应用程序在读取该库生成的
ply文件时居然有一些warning。我觉得可能是该库的这个版本太老的缘故，因为尝试自行构建该库的最新版本。不过，目前尚未完成这个探索。
\end_layout

\begin_layout Standard
下载。从https://github.com/PointCloudLibrary/pcl下载源代码。
\end_layout

\begin_layout Standard
准备。除了通常的工具外，还需要执行以下命令以安装一个库：
\end_layout

\begin_layout Standard
sudo apt install libusb-1.0-0-dev
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
构建。使用通常的cmake构建步骤。需要注意的是这个库很大，其中的C++部分的代码行数高达50万行。应该选择性能高的机器来编译，在我的工作机上编译时导致系统死机
。
\end_layout

\begin_layout Subsection
接口
\end_layout

\begin_layout Subsubsection
从软件源安装的
\end_layout

\begin_layout Standard
头文件。目录位于/usr/include/pcl-1.10/。
\end_layout

\begin_layout Standard
库。位于/usr/lib/x86_64-linux-gnu/。基本库为libpcl_common.so，其他的是各个模块对应的库，用户依据自己的需要使用。所有库的
列表如下。
\end_layout

\begin_layout Verbatim
pcl_apps      pcl_keypoints     pcl_sample_consensus
\end_layout

\begin_layout Verbatim
pcl_common    pcl_ml            pcl_search
\end_layout

\begin_layout Verbatim
pcl_features  pcl_octree        pcl_segmentation
\end_layout

\begin_layout Verbatim
pcl_filters   pcl_outofcore     pcl_stereo
\end_layout

\begin_layout Verbatim
pcl_io_ply    pcl_people        pcl_surface
\end_layout

\begin_layout Verbatim
pcl_io        pcl_recognition   pcl_tracking
\end_layout

\begin_layout Verbatim
pcl_kdtree    pcl_registration  pcl_visualization
\end_layout

\begin_layout Standard
和cmake的接口。位于/usr/lib/x86_64-linux-gnu/cmake/pcl/。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
文档。
\end_layout

\begin_layout Standard
https://pcl-tutorials.readthedocs.io，导论。
\end_layout

\begin_layout Subsubsection
自行构建的
\end_layout

\begin_layout Standard
头文件。位于/usr/local/include/pcl-1.13/。
\end_layout

\begin_layout Standard
库。位于/usr/local/lib
\end_layout

\begin_layout Standard
cmake接口文件。位于/usr/local/share/pcl-1.13/Modules。
\end_layout

\begin_layout Standard
可执行文件。位于/usr/local/bin。
\end_layout

\begin_layout Subsection
概述
\end_layout

\begin_layout Standard
官网。https://pointclouds.org。于2010年发布。
\end_layout

\begin_layout Standard
源代码。位于https://github.com/PointCloudLibrary/pcl。采用C++语言开发，采用cmake构建。
\end_layout

\begin_layout Standard
该库功能丰富，被分为若干模块，涵盖点云图处理的多个方面，每个模块对应着一个单独的库，可以被单独构建。https://en.wikipedia.org/wiki/Po
int_Cloud_Library介绍了各个模块的功能。
\end_layout

\begin_layout Subsection
PointCloud<PointT>
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
https://pcl.readthedocs.io/en/latest/basic_structures.html
\end_layout

\begin_layout Standard
https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html#details。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
这是该库的一个核心类模块，表示点云，逻辑上是一个点的序列，可以被用来表示点云以外的数据。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该类模板的接口和vector的有些相似，不过它并不是一个vector。
\end_layout

\begin_layout Subsubsection
点的类型
\end_layout

\begin_layout Standard
文献。https://pcl.readthedocs.io/en/latest/adding_custom_ptype.html#adding-custom-ptyp
e
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
前一节的类型PointCloud的模板参数表示点云中点的类型。该库定义了多种点类型，头文件/usr/include/pcl-1.10/pcl/impl/point
_types.hpp含有这些类型的声明。以下是一些常用的类型。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
PointXY。表示
\begin_inset Formula $(x,y)$
\end_inset

。
\end_layout

\begin_layout Standard
PointXYZ。表示点的三维坐标
\begin_inset Formula $(x,y,z)$
\end_inset

，其定义如下：
\end_layout

\begin_layout Verbatim
union
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
  float data[4];
\end_layout

\begin_layout Verbatim
  struct
\end_layout

\begin_layout Verbatim
  {
\end_layout

\begin_layout Verbatim
    float x;
\end_layout

\begin_layout Verbatim
    float y;
\end_layout

\begin_layout Verbatim
    float z;
\end_layout

\begin_layout Verbatim
  };
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Standard
可以使用诸如points[i].x或者points[i].data[0]的方式来访问。令该类型占用4个floats，因为有些算法会使用齐次坐标，需要在上述成员之后加
上一维。还有的并行算法所使用的SSE指令要求处理对象是4个floats。这种做法在以下的类型中也会被使用。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
PointXYZI。表示一个
\begin_inset Formula $(x,y,z,i)$
\end_inset

元组，其中
\begin_inset Formula $i$
\end_inset

是点的亮度（intensity）。其定义如下：
\end_layout

\begin_layout Verbatim
union
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
  float data[4];
\end_layout

\begin_layout Verbatim
  struct
\end_layout

\begin_layout Verbatim
  {
\end_layout

\begin_layout Verbatim
    float x;
\end_layout

\begin_layout Verbatim
    float y;
\end_layout

\begin_layout Verbatim
    float z;
\end_layout

\begin_layout Verbatim
  };
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Verbatim
union
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
  struct
\end_layout

\begin_layout Verbatim
  {
\end_layout

\begin_layout Verbatim
    float intensity;
\end_layout

\begin_layout Verbatim
  };
\end_layout

\begin_layout Verbatim
  float data_c[4];
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Standard
与前文类似，为
\begin_inset Formula $(x,y,z)$
\end_inset

部分补一个额外float，令其占用4个floats。对于intensity部分，出于SSE指令对齐的要求，我们也令其占用4个floats。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
RGB。表示
\begin_inset Formula $(r,g,b,a$
\end_inset

)，其定义如下。
\end_layout

\begin_layout Verbatim
 union{ 
\end_layout

\begin_layout Verbatim
    union{ 
\end_layout

\begin_layout Verbatim
      struct{ 
\end_layout

\begin_layout Verbatim
        std::uint8_t b;     // 注意分量的顺序是BGRA，而不是RGBA。这个顺序和OpenCV中的一致。
\end_layout

\begin_layout Verbatim
        std::uint8_t g; 
\end_layout

\begin_layout Verbatim
        std::uint8_t r; 
\end_layout

\begin_layout Verbatim
        std::uint8_t a; 
\end_layout

\begin_layout Verbatim
      }; 
\end_layout

\begin_layout Verbatim
      float rgb; 
\end_layout

\begin_layout Verbatim
    }; 
\end_layout

\begin_layout Verbatim
    std::uint32_t rgba;
\end_layout

\begin_layout Verbatim
  };
\end_layout

\begin_layout Standard
PointXYZRGBA。表示
\begin_inset Formula $(x,y,z)$
\end_inset

，以及
\begin_inset Formula $\text{(r,g,b,a)}$
\end_inset

。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
Normal。表示切平面的法向量，曲率。该结构体实际存放了8个floats，这样做的原因和前文一样，其具体定义如下。
\end_layout

\begin_layout Verbatim
union
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
  float data_n[4];
\end_layout

\begin_layout Verbatim
  float normal[3];
\end_layout

\begin_layout Verbatim
  struct
\end_layout

\begin_layout Verbatim
  {
\end_layout

\begin_layout Verbatim
    float normal_x;
\end_layout

\begin_layout Verbatim
    float normal_y;
\end_layout

\begin_layout Verbatim
    float normal_z;
\end_layout

\begin_layout Verbatim
  };
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Verbatim
union
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
  struct
\end_layout

\begin_layout Verbatim
  {
\end_layout

\begin_layout Verbatim
    float curvature;
\end_layout

\begin_layout Verbatim
  };
\end_layout

\begin_layout Verbatim
  float data_c[4];
\end_layout

\begin_layout Verbatim
};
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Subsubsection
类型别名
\end_layout

\begin_layout Standard
该类模板定义了以下类型别名，以便于用户使用。
\end_layout

\begin_layout Standard
VectorType。就是上述数据成员points的类型。
\end_layout

\begin_layout Standard
Ptr。是一个shared_ptr对象，所指目标为一个点云。
\end_layout

\begin_layout Standard
iterator。就是points的类型中的迭代器。
\end_layout

\begin_layout Subsubsection
构造
\end_layout

\begin_layout Standard
PointCloud()。
\end_layout

\begin_layout Standard
PointCloud(uint32_t width_, uint32_t height_, const PointT & value_ = PointT
 ())。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
复制构造。该类模板并没有定义复制构造函数。但是，通过阅读该类模板的源代码，可以推断该类模板使用编译器合成的复制构造函数就能够实现完整的复制构造。
\end_layout

\begin_layout Subsubsection
共有成员
\end_layout

\begin_layout Standard
PCLHeader header。类型PCLHeader表示一个点云的标识以及获得时间。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
uint32_t width。 
\end_layout

\begin_layout Standard
uint32_t height。这两个成员的含义和点云是否有组织（organized）相关。对于某些点云，比如从立体相机数据计算得到的相对左相机的点云图，每个点
本身存放着一个物理点的
\begin_inset Formula $(x,y,z)$
\end_inset

坐标，同时，如果将这些点看做基本处理对象，它们是和左相机采集到的图像的像素点对应的，因而，给定图像的行、列坐标，则对应着一个点。一些算法需要或者可以利用这种对应
关系。因而，该库在上述points中存放这些点的时候，会按照逐行的方式顺序。这样所得的点云就是有组织的。成员width和height就表示上述图像的宽度和高度。
\end_layout

\begin_layout Standard
一些点云是未组织的，比如从激光雷达得到的点云数据，根本就不存在上述的图像的概念。此时，width被设置为点云中点的总数，而height被设置为1。也就是说hei
ght的取值能够表征一个点云是否是有组织的。不过，用户并不需要直接这样做，类模板PointCloud<T>提供了一个成员函数isOrganized()可以返回这
个信息。相关的文献参https://pcl.readthedocs.io/en/latest/basic_structures.html，以及https://stac
koverflow.com/questions/18994680/can-anyone-explain-the-difference-between-organi
zed-and-unorganized-point-cloud。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
vector<PointT, Eigen::aligned_allocator<PointT> > points。该成员存放点云数据。点云在逻辑上可以是一维、二
维、三维甚至更高维的，但是它们的数据都被存放在这个一维容器中。
\end_layout

\begin_layout Standard
目前张波还不清楚什么情形下需要直接使用该成员。如果需要使用时，一个注意事项是，这个成员的类型不同于vector<PointT>。用户可以使用本类模板中定义的类型
别名VectorType来引用该类型。
\end_layout

\begin_layout Subsubsection
基本信息
\end_layout

\begin_layout Standard
empty()。
\end_layout

\begin_layout Standard
size_t size ( ) const。
\end_layout

\begin_layout Subsubsection
点的访问
\end_layout

\begin_layout Standard
PointT& front()。
\end_layout

\begin_layout Standard
PointT& at(int column, int row) 。对于有组织点云，返回指定列、行的点，注意坐标的顺序（和访问矩阵时的相反）。
\end_layout

\begin_layout Standard
PointT& at(size_t n) 。将点云看做一个一维序列，返回指定序号的点。
\end_layout

\begin_layout Standard
PointT& back()。将点云看做一个一维序列，返回最后一个点。
\end_layout

\begin_layout Standard
PointT* data() 。返回points.data，使得用户可以使用物理指针直接操作点。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该类型重载了[]运算符，提供了“[index]”形式的调用。
\end_layout

\begin_layout Standard
PointT & operator[] (std::size_t n)。
\end_layout

\begin_layout Standard
重载了以下()运算符，提供了“(col,row)”形式的调用。
\end_layout

\begin_layout Standard
PointT & operator() (std::size_t column, std::size_t row)。
\end_layout

\begin_layout Subsubsection
添加点
\end_layout

\begin_layout Standard
void push_back(const PointT & pt)。
\end_layout

\begin_layout Subsubsection
删除点
\end_layout

\begin_layout Standard
iterator erase (iterator position)
\end_layout

\begin_layout Standard
iterator erase (iterator first, iterator last)
\end_layout

\begin_layout Standard
clear()。
\end_layout

\begin_layout Subsubsection
序列长度的更改
\end_layout

\begin_layout Standard
void resize(index_t count)。
\end_layout

\begin_layout Standard
void resize(index_t count, const PointT & value )。
\end_layout

\begin_layout Standard
void resize(index_t new_width, index_t new_height)。
\end_layout

\begin_layout Standard
void resize(index_t new_width, index_t new_height, const PointT & value)
 。
\end_layout

\begin_layout Subsubsection
迭代器
\end_layout

\begin_layout Standard
iterator begin() 。
\end_layout

\begin_layout Standard
iterator end()。
\end_layout

\begin_layout Subsubsection
序列的拼接
\end_layout

\begin_layout Standard
可以使用该类模板的成员函数，或者静态成员函数。
\end_layout

\begin_layout Standard
相关的普通成员函数如下。
\end_layout

\begin_layout Standard
PointCloud& operator += (const PointCloud& rhs)。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该类模板定义了以下实现拼接的静态成员函数。
\end_layout

\begin_layout Verbatim
static bool concatenate(PointCloud<PointT>& cloud1, const PointCloud<PointT>&
 cloud2)。
\end_layout

\begin_layout Verbatim
将cloud2拼接在cloud1的尾部。
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
static bool concatenate(const PointCloud<PointT>& cloud1, const PointCloud<Point
T>& cloud2,
\end_layout

\begin_layout Verbatim
                        PointCloud<PointT>& cloud_out)。
\end_layout

\begin_layout Standard
拼接cloud1与cloud2，结果存放在cloud_out中。
\end_layout

\begin_layout Subsection
在堆中创建点云对象
\end_layout

\begin_layout Standard
pcl库的用户一般应该在堆中创建点云对象，而不是在栈存储区创建。具体地，建议的做法的一个例子如下：
\end_layout

\begin_layout Standard
PointCloud<PointXYZ>::Ptr cloud (new PointCloud<PointXYZ>);
\end_layout

\begin_layout Standard
而不是：
\end_layout

\begin_layout Standard
PointCloud<PointXYZ> cloud;
\end_layout

\begin_layout Standard
其中的Ptr类型，以及另外一个相关的类型ConstPtr，的定义如下：
\end_layout

\begin_layout Standard
using Ptr = shared_ptr<PointCloud<PointT> >;
\end_layout

\begin_layout Standard
using ConstPtr = shared_ptr<const PointCloud<PointT> >;
\end_layout

\begin_layout Standard
可以看到这两个类型都是引用了C++的shared_ptr，而后者一定是指向堆中创建的对象。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
原因。这样做的原因是pcl库中的一些操作只接收上述Ptr或者ConstPtr类型的输入数据。例如，类模板PCLBase的以下函数：
\end_layout

\begin_layout Standard
virtual void setInputCloud (const PointCloudConstPtr &cloud);
\end_layout

\begin_layout Standard
该函数被很多pcl库中的算法来设置输入点云，而该函数要求输入参数必须是上述ConstPtr类型的。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
关于PointCloud<PointT>::Ptr()。类模板PointCloud<PointT>提供了以下函数，依据当前点云对象，在堆中深度复制一个新的点云对
象，并返回指向它的一个类型为Ptr（也就是shared_ptr）的指针。
\end_layout

\begin_layout Standard
Ptr makeShared () const { return Ptr (new PointCloud<PointT> (*this)); }
\end_layout

\begin_layout Standard
不过，正如源代码中的注释所说，一般不要对一个非空的点云对象施加上述运算，因为这个操作执行深度复制，代价较大。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
总之，一个应用程序在最初创建点云对象时，最好在堆中创建。
\end_layout

\begin_layout Subsection
点云数据的IO
\end_layout

\begin_layout Standard
该库支持多种IO格式，我们目前使用PLY格式，因为我们所使用的点云图查看软件支持该格式而不支持PCD格式。
\end_layout

\begin_layout Subsubsection
PLY格式读写
\end_layout

\begin_layout Standard
该格式的缺点。以文本方式存储数据，占用空间大，IO速度慢。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
头文件。pcl/io/ply_io.h。
\end_layout

\begin_layout Standard
名字空间。pcl。
\end_layout

\begin_layout Paragraph
类PLYReader
\end_layout

\begin_layout Standard
读取PLY格式的点云图数据。该类的文档参https://pointclouds.org/documentation/classpcl_1_1_p_l_y_read
er.html#details。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该类提供了一组点云图或者PolygonMesh的读取函数，和我们最相关的一个如下。
\end_layout

\begin_layout Standard
template<typename PointT >
\end_layout

\begin_layout Standard
int read(const std::string & file_name, pcl::PointCloud<PointT>& cloud,
 const int offset=0) 
\end_layout

\begin_layout Standard
从指定的文件读取点云数据，存放在参数cloud中。参offet为PLY文件的头的偏移量，一般为0。如果多个点云图数据被存放在一个tar格式的文件中，由于tar文
件会在首个文件数据的前面加上512字节的头，所以应该将该参数设置为513。
\end_layout

\begin_layout Paragraph
类PLYWriter
\end_layout

\begin_layout Standard
以ply格式输出点云数据。该类的文档参https://pointclouds.org/documentation/classpcl_1_1_p_l_y_write
r.html。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该类提供了一组点云图或者PolygonMesh的输出函数，和我们最相关的一个如下。
\end_layout

\begin_layout Standard
template<typename PointT >
\end_layout

\begin_layout Standard
int write (const std::string &file_name, const pcl::PointCloud< PointT >
 &cloud, bool binary=false, bool use_camera=true)
\end_layout

\begin_layout Standard
将点云数据写入到指定的文件中，可以使用二进制格式。采用二进制格式可以使文件长度更小，例如，某点云数据以文本方式存放时需要16M，而采用二进制时只需要6.5M。当然
，采用文本格式更容易看到其文件内容。目前尚不明白use_camera的含义。
\end_layout

\begin_layout Subsubsection
PCD格式
\end_layout

\begin_layout Standard
这种格式的存取速度更快。这个格式也在演化中，文件头部会含有一个版本信息。截止到2022年，版本为0.7。一个例子如下。
\end_layout

\begin_layout Verbatim
VERSION .7
\end_layout

\begin_layout Verbatim
FIELDS x y z rgb
\end_layout

\begin_layout Verbatim
SIZE 4 4 4 4
\end_layout

\begin_layout Verbatim
TYPE F F F F
\end_layout

\begin_layout Verbatim
COUNT 1 1 1 1
\end_layout

\begin_layout Verbatim
WIDTH 213
\end_layout

\begin_layout Verbatim
HEIGHT 1
\end_layout

\begin_layout Verbatim
VIEWPOINT 0 0 0 1 0 0 0
\end_layout

\begin_layout Verbatim
POINTS 213
\end_layout

\begin_layout Verbatim
DATA ascii
\end_layout

\begin_layout Verbatim
0.93773 0.33763 0 4.2108e+06
\end_layout

\begin_layout Verbatim
0.90805 0.35641 0 4.2108e+06
\end_layout

\begin_layout Verbatim
0.81915 0.32 0 4.2108e+06
\end_layout

\begin_layout Verbatim
0.97192 0.278 0 4.2108e+06
\end_layout

\begin_layout Verbatim
...
\end_layout

\begin_layout Standard
文件头。依次含有以下域，每个域以换行符结束。
\end_layout

\begin_layout Standard
- VERSION。PCD格式的版本号。
\end_layout

\begin_layout Standard
- FIELDS。一个点的数据包含哪些成员。一些例子：
\end_layout

\begin_layout Verbatim
FIELDS x y z          # XYZ data
\end_layout

\begin_layout Verbatim
FIELDS x y z rgb      # XYZ + colors
\end_layout

\begin_layout Verbatim
-SIZE。列出各个维的一个基本元素的以字节为单位的长度。
\end_layout

\begin_layout Verbatim
-TYPE。列出各个维的一个基本元素的数据类型。可能的取值是：I,表示有符号整数，U，表示无符号整数，F表示浮点数。
\end_layout

\begin_layout Verbatim
-COUNT。列出各个维含有多少个基本元素，一般为1。
\end_layout

\begin_layout Verbatim
-WIDTH。
\end_layout

\begin_layout Verbatim
-HEIGHT。以上两个域的含义同类型PointCloud<PointT>中的。
\end_layout

\begin_layout Verbatim
-VIEWPOINT
\end_layout

\begin_layout Verbatim
-POINTS。点云中点的个数。
\end_layout

\begin_layout Verbatim
-DATA。指定数值的存放格式，取值为ascii或者binary。如果是ascii，每个点的数据以ASCII格式保存，占据一行。如果是binary，文件中存放的
就是PointClound<PointT>::points.data所指内存块的数据。
\end_layout

\begin_layout Standard
DATA域的下一行的第一个字节就是数据的起始。
\end_layout

\begin_layout Paragraph
函数
\end_layout

\begin_layout Standard
头文件。pcl/io/pcd_io.h
\end_layout

\begin_layout Standard
头文件中定义了一组自由函数来实现点云数据的IO。以下是常用的。
\end_layout

\begin_layout Standard
int savePCDFileASCII (const std::string &file_name, const pcl::PointCloud<PointT
> &cloud)。以ASCII-PCD格式保存。
\end_layout

\begin_layout Subsection
视差转换为点云
\end_layout

\begin_layout Standard
实现这个功能的是类模板DisparityMapConverter<PointT>。网上这方面的资料并不多，我阅读pcl库的源代码以获得更多知识，相关的源代码文件
是include/pcl/stereo/impl/disparity_map_converter.hpp（对应的cpp文件反而没有代码细节）。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
点的亮度信息。一般在讨论点云图时我们只需要存放每个点的三维坐标，但是可视化点云图时，出于渲染效果，可以令一个点关联额外信息，这可以通过令模板参数PointT取一
些特定类型来实现。
\end_layout

\begin_layout Standard
PointT的常见取值是PointXYZ以及PointXYZI。前者是一个元组
\begin_inset Formula $(x,y,z)$
\end_inset

，是点的三维坐标。后者是一个元组
\begin_inset Formula $(x,y,z,i)$
\end_inset

，前三个量是点的三维坐标，而第四个量是该点的亮度。对于PointXYZI，如果我们知道一个视差图对应的RGB图像，可以从该点对应的像素的R、G、B值计算其亮度（
就是这三个分量的平均值）。
\end_layout

\begin_layout Standard
一个DisparityMapConverter<PointXYZI>的对象刚被构造时，对每个点并不会存放上述亮度信息。当用户调用了以下的setImage函数之后
，将会令每个点关联一个亮度信息：
\end_layout

\begin_layout Standard
void setImage(const PointCloud<RGB>::ConstPtr& image)。设置一个能够存放视差图的图像对象。要求图像像素必须是
RGB格式的，不能是灰度格式的。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
视差信息的设置。
\end_layout

\begin_layout Standard
void setDisparityMap( const vector<float>& disparity_map) 。
\end_layout

\begin_layout Standard
void setDisparityMap( const vector<float>& disparity_map, const size_t width,
 const size_t height) 。从指定的容器中获得视差信息。要求该容器中的视差信息是逐个图像行（而不是列）存放的。第一个函数假设转换器已经被设置了
图像尺寸，比如用户此前调用过其setImage函数。如果用户的视差数据并不是按照逐列方式存放在文本文件中，应该调用这个函数来设置视差信息。
\end_layout

\begin_layout Standard
bool loadDisparityMap(const string& file_name, const size_t width, const
 size_t height)。从指定名字的文件中读取视差信息，存放到一个内部对象中。要求该文件必须以文本方式存放视差信息，逐个图像列存放。
\end_layout

\begin_layout Standard
bool loadDisparityMap(const std::string& file_name)。和上面的函数类似，只不过图像的维数信息由上述setIma
ge执行时确定。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
点的信息的计算。这是该类模板的核心功能。对应的函数如下。
\end_layout

\begin_layout Standard
void compute(PointCloud& out_cloud)。
\end_layout

\begin_layout Standard
该函数所执行的计算和计算机视觉学习笔记中的“三角测量法获得物理点的坐标”的本质是一样的，只不过所用的公式不同，计算公式如下：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
z_{s}=\frac{b\cdot f}{x_{L}-x_{R}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x_{s}=\frac{x_{L}\cdot z_{s}}{f}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
y_{s}=\frac{y\cdot z_{s}}{f}
\]

\end_inset


\end_layout

\begin_layout Subsection
滤波
\end_layout

\begin_layout Standard
pcl库提供了一组丰富的滤波器，细节参http://pointclouds.org/documentation/group__filters.html。
\end_layout

\begin_layout Subsubsection
尽量使用pcl中的滤波器而不是直接操作点云
\end_layout

\begin_layout Standard
如果用户想要施加的一个点云操作在pcl库中有相应的滤波器，应该尽量使用pcl库中，而不是手工重新实现，原因是pcl库中的会快很多。例如，如果手工实现一个删除深度
大于某个阀值的点的操作，可能的代码如下：
\end_layout

\begin_layout Verbatim
for (auto it=cloud.begin(); it!=cloud.end(); ){
\end_layout

\begin_layout Verbatim
    if (it->z > distanceLimit){
\end_layout

\begin_layout Verbatim
        it = cloud.erase(it);
\end_layout

\begin_layout Verbatim
        continue;
\end_layout

\begin_layout Verbatim
    }
\end_layout

\begin_layout Verbatim
    it++;
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
由于需要执行很多次数据删除/内存块重新组织操作，对于一个具有424,962点的点云，上述代码的执行需要4545.77 ms。而如果使用pcl中的PassThrou
gh<PointT>滤波器，这个操作只需要8 ms。
\end_layout

\begin_layout Subsubsection
基类PCLBase<PointT>
\end_layout

\begin_layout Standard
该类模板定义大多数算法的接口。
\end_layout

\begin_layout Standard
void setInputCloud (const PointCloudConstPtr & cloud)。
\end_layout

\begin_layout Standard
设置输入点云对象。
\end_layout

\begin_layout Subsubsection
基类Filter<PointT>
\end_layout

\begin_layout Standard
该类定义了以下公有成员函数，供用户调用：
\end_layout

\begin_layout Standard
void filter(PointCloud &output)。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
FilterIndices<PointT>
\end_layout

\begin_layout Standard
pcl库中有多个滤波器，比如下文的PassThrough以及RadiusOutlierRemoval，所执行的操作都可以被归结为对每个输入点的保留/移除操作。本
类模板实现该操作。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
接口方面，除了父类定义的那个filter(PointCloud &output)之外，该类模板还定义了以下的公有虚函数：
\end_layout

\begin_layout Standard
virtual void filter(Indices &indices)。
\end_layout

\begin_layout Standard
这是一个抽象函数，派生类应该实现这个函数，以输出被保留的点的索引。类型Indices等价于vector<uint32_t>，是点索引的容器。
\end_layout

\begin_layout Standard
用户在以下情形下会调用该函数，以获得被保留的点的索引：当有一系列保留/移除的滤波操作时，除了最后那个之外，其他滤波操作只需要得到被保留点的索引，而无需实际执行滤
波操作。这样做会更加高效（因为实际的点的移除操作是一个代价较大的操作）。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
void setNegative(bool negative)。
\end_layout

\begin_layout Standard
如果为true，将滤波操作中默认的“保留”替换为“移除”，将“移除”替换为“保留”。为false则执行原本的保留/移除操作。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
直通滤波/PassThrough<PointT>
\end_layout

\begin_layout Standard
文献。http://pointclouds.org/documentation/classpcl_1_1_pass_through.html
\end_layout

\begin_layout Standard
类模板PassThrough<PointT>实现这样的一个滤波操作：依据用户设置的一个点属性的上下界，只允许那些属性满足这些设定的点通过。每次滤波只能依据某一个
属性而不能是若干个属性。
\end_layout

\begin_layout Standard
该类模板的继承关系如下图：
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/classPassThrough_diagram.png

\end_inset


\end_layout

\begin_layout Standard
该类模板的常用成员函数如下：
\end_layout

\begin_layout Standard
void setFilterFieldName (const std::string &field_name)。
\end_layout

\begin_layout Standard
设置所依据的属性的名字。只能指定一个属性的名字。
\end_layout

\begin_layout Standard
void setFilterLimits(const float &limit_min, const float &limit_max)。
\end_layout

\begin_layout Standard
指定上下界。
\begin_inset space \space{}
\end_inset

可以使用numeric_limits<float>::lowest()表示最负的那个浮点数，numeric_limits<float>::max()表示最正的那
个浮点数。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
一个样例如下。
\end_layout

\begin_layout Verbatim
pcl::PassThrough<PointType> ptfilter(true); // Initializing with true will
 
\end_layout

\begin_layout Verbatim
                                            // allow us to extract the removed
 indices
\end_layout

\begin_layout Verbatim
ptfilter.setInputCloud(cloud_in);
\end_layout

\begin_layout Verbatim
ptfilter.setFilterFieldName("x");
\end_layout

\begin_layout Verbatim
ptfilter.setFilterLimits(0.0, 1000.0);
\end_layout

\begin_layout Verbatim
ptfilter.filter(*indices_x);
\end_layout

\begin_layout Verbatim
// The indices_x array indexes all points of cloud_in that have x between
 0.0 and 1000.0
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
indices_rem = ptfilter.getRemovedIndices ();
\end_layout

\begin_layout Verbatim
// The indices_rem array indexes all points of cloud_in that have x smaller
 than 0.0 
\end_layout

\begin_layout Verbatim
// or larger than 1000.0, and also indexes all non-finite points of cloud_in
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
ptfilter.setIndices(indices_x);
\end_layout

\begin_layout Verbatim
ptfilter.setFilterFieldName ("z");
\end_layout

\begin_layout Verbatim
ptfilter.setFilterLimits(-10.0, 10.0);
\end_layout

\begin_layout Verbatim
ptfilter.setNegative(true);
\end_layout

\begin_layout Verbatim
ptfilter.filter(*indices_xz);
\end_layout

\begin_layout Verbatim
// The indices_xz array indexes all points of cloud_in that have x between
 0.0 and 1000.0
\end_layout

\begin_layout Verbatim
// and z larger than 10.0 or smaller than -10.0
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
ptfilter.setIndices (indices_xz);
\end_layout

\begin_layout Verbatim
ptfilter.setFilterFieldName("intensity");
\end_layout

\begin_layout Verbatim
ptfilter.setFilterLimits(std::numeric_limits<float>::lowest(), 0.5);
\end_layout

\begin_layout Verbatim
ptfilter.setNegative(false);
\end_layout

\begin_layout Verbatim
ptfilter.filter(*cloud_out);
\end_layout

\begin_layout Verbatim
// The resulting cloud_out contains all points of cloud_in that are finite
 and have:
\end_layout

\begin_layout Verbatim
// x between 0.0 and 1000.0, z larger than 10.0 or smaller than -10.0 and intensity
 smaller than 0.5.
\end_layout

\begin_layout Subsubsection
下采样/VoxelGrid
\end_layout

\begin_layout Standard
文献。
\end_layout

\begin_layout Standard
http://pointclouds.org/documentation/classpcl_1_1_voxel_grid.html。
\end_layout

\begin_layout Standard
https://pointclouds.org/documentation/tutorials/voxel_grid.html，官方的例子，使用PCLPointCl
oud2表示一个点云。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
将3D空间等分为若干尺寸完全相同的、没有重叠的立体区域，被称为voxel grids。给定这样的一个区域，如果点云图中没有点落在该区域，不输出任何信息。否则，
 计算所有落入该区域的点的质心（centroid），输出该质心。对所有区域执行上述操作，得到另外一个点云图。输出点云图的性质：点的数量会大幅减少；能够保留原点云
图中点的分布细节（如果区域设置的小）或者能够刻画粗粒度的点的分布（如果区域设置的大）。这个操作的主要目的是降低运算量。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
pcl库提供了类模板VoxelGrid<PointT>来实现这个操作。该类与相关类的关系如下图：
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/voxelGrid_class_diagram.png

\end_inset


\end_layout

\begin_layout Standard
头文件。#include <pcl/filters/voxel_grid.h>
\end_layout

\begin_layout Standard
常用的成员函数如下。
\end_layout

\begin_layout Standard
void setLeafSize (float lx, float ly, float lz)。
\end_layout

\begin_layout Standard
设置grid中的一个（立体）单元的形状，其单位和点云中的长度单位一致。
\end_layout

\begin_layout Standard
void applyFilter (PointCloud & output)。
\end_layout

\begin_layout Standard
这是基类中的对应虚函数的实现，执行下采样操作。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
样例代码如下。
\end_layout

\begin_layout Verbatim
PointCloud<PointXYZ>::Ptr cloud (new PointCloud<PointXYZ>);
\end_layout

\begin_layout Verbatim
VoxelGrid<PointXYZ> downsampler;
\end_layout

\begin_layout Verbatim
downsampler.setInputCloud (cloud);
\end_layout

\begin_layout Verbatim
downsampler.setLeafSize (0.5, 0.5, 0.5);
\end_layout

\begin_layout Verbatim
downsampler.filter(*cloud);
\end_layout

\begin_layout Subsubsection
异常点移除/RadiusOutlierRemoval
\end_layout

\begin_layout Standard
文献。http://pointclouds.org/documentation/classpcl_1_1_radius_outlier_removal.html
\end_layout

\begin_layout Standard
类模板RadiusOutlierRemoval<PointT>遍历每个点，如果一个点在指定的半径内的邻居数少于指定的阀值时，会被判定为一个异常点。遍历完毕后，删
除所有异常点。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
以下是常用成员函数：
\end_layout

\begin_layout Standard
void setRadiusSearch (double radius)。
\end_layout

\begin_layout Standard
设置上述半径。
\end_layout

\begin_layout Standard
void setMinNeighborsInRadius (int min_pts)。
\end_layout

\begin_layout Standard
设置上述邻居数的阀值。
\end_layout

\begin_layout Section
和dbscan相关的库
\end_layout

\begin_layout Subsection
mlpack
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
文档。https://github.com/mlpack/mlpack/tree/master/doc。有高质量文档。文档被分为C++库以及其他语言绑定两个部分。
\end_layout

\begin_layout Standard
C++部分，文档主要以代码注释的形式呈现。例如，对于dbscan，开发者应该查看目录/usr/local/include/mlpack/methods/dbsc
an下的代码。另外一个可以参考的是该项目的样例程序（参下文）。
\end_layout

\begin_layout Subsubsection
安装
\end_layout

\begin_layout Paragraph
自行构建
\end_layout

\begin_layout Standard
由于从软件源中的安装的库的版本太低，我们使用本节的自行构建的方式，这样可以得到库的最新版。
\end_layout

\begin_layout Standard
依赖。sudo apt-get install libarmadillo-dev libensmallen-dev libcereal-dev
 libstb-dev
\end_layout

\begin_layout Standard
构建。由于该库的代码量大（大约为20万行），可以使用sw机器构建，普通机器耗费的时间太长。
\end_layout

\begin_layout Standard
执行普通的cmake构建操作即可。
\end_layout

\begin_layout Standard
库的迁移。在性能较好的机器构建完毕后，将该库的头文件、可执行文件复制到工作机器即可。
\end_layout

\begin_layout Paragraph
从软件源安装
\end_layout

\begin_layout Standard
软件源有这个库，名字为mlpack-dev，版本为3.2.2-3，而最新版为4.3.0。
\end_layout

\begin_layout Subsubsection
样例
\end_layout

\begin_layout Standard
该库有两个类型的样例：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

该库本身含有的测试数据，位于src/mlpack/tests/data/，其文档会给出一些样例，演示如何使用该库操作这些数据。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

官方还发布了一个独立的样本程序库，位于https://github.com/mlpack/examples/。其中的contact_tracing_cluster
ing_with_dbscan演示了如何使用该库的dbscan算法。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
库接口
\end_layout

\begin_layout Paragraph
自行构建的
\end_layout

\begin_layout Standard
头文件。位于/usr/local/include/，主头文件为mlpack.hpp，它只是简单的包含了其他的头文件。其他文件位于子目录mlpack。
\end_layout

\begin_layout Standard
名字空间。mlpack。
\end_layout

\begin_layout Standard
可执行程序。位于/usr/local/bin/，以“mlpack_”打头。
\end_layout

\begin_layout Paragraph
从软件源安装的
\end_layout

\begin_layout Standard
头文件。位于/usr/include/mlpack。
\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
https://github.com/mlpack/mlpack。是一个C++机器学习库，同时，还提供了多种语言的API，包括Python，R等。含有dbscan
。官网https://www.mlpack.org。相关文章是2023年的，项目本身活跃，关注度高。
\end_layout

\begin_layout Subsubsection
邻居搜索/类模板NeighborSearch
\end_layout

\begin_layout Standard
给定一个查询数据集（query dataset）以及一个参考数据集（reference dataset），对于前者中的每个点，该类模板在参考数据集中，寻找最满足
搜索条件（都是基于点之间距离定义的）的点，返回这些点的索引以及对应距离。
\end_layout

\begin_layout Standard
该库允许用户不指定查询数据集而只提供一个参考数据集。此时，该类模板对该数据集的每一个点执行上述搜索。
\end_layout

\begin_layout Paragraph
模板参数
\end_layout

\begin_layout Standard
这个类模板的模板参数如下：
\end_layout

\begin_layout Verbatim
template<
\end_layout

\begin_layout Verbatim
  typename SortPolicy = NearestNeighborSort,
\end_layout

\begin_layout Verbatim
  typename MetricType = EuclideanDistance,
\end_layout

\begin_layout Verbatim
  typename MatType = arma::mat,
\end_layout

\begin_layout Verbatim
  template<typename TreeMetricType,
\end_layout

\begin_layout Verbatim
           typename TreeStatType,
\end_layout

\begin_layout Verbatim
           typename TreeMatType> class TreeType = KDTree,
\end_layout

\begin_layout Verbatim
  template<typename RuleType> class TraversalType =
\end_layout

\begin_layout Verbatim
      TreeType<MetricType, NeighborSearchStat<SortPolicy>,
\end_layout

\begin_layout Verbatim
               MatType>::template DualTreeTraverser>
\end_layout

\begin_layout Verbatim
  template<typename RuleType> class SingleTreeTraversalType =
\end_layout

\begin_layout Verbatim
      TreeType<MetricType,
\end_layout

\begin_layout Verbatim
               NeighborSearchStat<SortPolicy>,
\end_layout

\begin_layout Verbatim
               MatType>::template SingleTreeTraverser>
\end_layout

\begin_layout Verbatim
>
\end_layout

\begin_layout Verbatim
class NeighborSearch;
\end_layout

\begin_layout Standard
从模板参数可以看出这个类模板是一个非常灵活、功能强大的邻居搜索器。每个模板参数都有默认值，对于常见的应用，用户可以不指定或者只指定少量的模板参数，就可以使用该类
模板。以下是各个模板参数的含义。
\end_layout

\begin_layout Standard
SortPolicy。指定一个类，NeighborSearch将使用该类来决定哪些点将被搜索。常用的类是NearestNeighborSort以及Furthes
tNeighborSort，分别执行最近邻以及最远邻搜索。如果用户想要定义自己的SortPolicy，需要模仿上述两个类定义类的接口。
\end_layout

\begin_layout Standard
MetricType。定义如何度量两个点的距离。
\end_layout

\begin_layout Standard
MatType。矩阵类型。要求其API符合armadillo中矩阵类的。一般取arma::mat或者arma::sp_mat。
\end_layout

\begin_layout Standard
TreeType。紧邻搜索使用诸如R-tree等来加速点的索引。NeighborSearch允许用户使用多种与R-tree类似的树来加速，常见的有KDTree,
 BallTree, StandardCoverTree, RTree或者RStarTree。默认的是KDTree（而不是Rtree）。
\end_layout

\begin_layout Standard
TraversalType。和树的遍历相关，目前还不理解其含义。
\end_layout

\begin_layout Standard
SingleTreeTraversalType。同上。
\end_layout

\begin_layout Paragraph
预定义的类型
\end_layout

\begin_layout Standard
该类模板预定义了以下类型，表示对参考数据集中点的索引的树。
\end_layout

\begin_layout Standard
typedef TreeType<MetricType, NeighborSearchStat<SortPolicy>, MatType> Tree;
\end_layout

\begin_layout Paragraph
构造函数
\end_layout

\begin_layout Standard
该类模板提供了好几个构造函数，一些从用户直接接收参考数据集，然后类模板执行构建一颗索引树。另外一些从用户接收一颗索引树，只是从这棵树复制得到另外一颗索引树。在选
择构造函数时，需要考虑本项目使用knn搜索的场景：我们使用knn仅仅是为了确定DBSCAN算法的参数Eps。而且，是针对所有帧执行这个操作。即使对每个帧我们单独
构建一个索引树，我们也不宜保存这些索引树以令此后的DBSCAN聚类操作来复用，因为这些索引树的数量太大了。因此，我们应该从上述第一组构造函数中选择一个适合我们的
。出于这个考虑，本项目中会用到的构造函数如下。
\end_layout

\begin_layout Verbatim
NeighborSearch(MatType referenceSet,
\end_layout

\begin_layout Verbatim
               const NeighborSearchMode mode = DUAL_TREE_MODE,
\end_layout

\begin_layout Verbatim
               const double epsilon = 0,
\end_layout

\begin_layout Verbatim
               const MetricType metric = MetricType());
\end_layout

\begin_layout Standard
各个函数参数的含义如下。
\end_layout

\begin_layout Standard
MatType referenceSet。该类模板会在内部构建参考数据集的一个副本，不会更改实参。该参数是一个矩阵。设参考数据集中点的维数为M，点的个数为N，则
这个矩阵具有M行、N列，每列表示参考数据集中的一个点（的坐标）。
\end_layout

\begin_layout Standard
NeighborSearchMode mode。枚举类型NeighborSearchMode的可能取值如下：
\end_layout

\begin_layout Standard
NAIVE_MODE。
\end_layout

\begin_layout Standard
SINGLE_TREE_MODE。
\end_layout

\begin_layout Standard
DUAL_TREE_MODE。
\end_layout

\begin_layout Standard
GREEDY_SINGLE_TREE_MODE。
\end_layout

\begin_layout Standard
目前尚不知道上述枚举常量的含义。
\end_layout

\begin_layout Paragraph
析构函数
\end_layout

\begin_layout Standard
主要是析构构造函数中创建的那个索引树。
\end_layout

\begin_layout Paragraph
搜索
\end_layout

\begin_layout Standard
该类模板提供多个搜索函数，本项目中可能会用到的如下。
\end_layout

\begin_layout Verbatim
void Search(const size_t k,
\end_layout

\begin_layout Verbatim
            arma::Mat<size_t>& neighbors, arma::mat& distances);
\end_layout

\begin_layout Standard
对参考数据集中的每个点，搜索其k-紧邻。设数据集的点的个数为n，输出矩阵的信息如下：
\end_layout

\begin_layout Standard
neighbors。k行n列。第j列、第i行存放参考数据集中第j个点的第i个紧邻点在参考数据集中的索引。
\end_layout

\begin_layout Standard
distances。k行n列。第j列、第i行存放参考数据集中第j个点到第i个紧邻点的距离。
\end_layout

\begin_layout Subsubsection
k-近邻搜索
\end_layout

\begin_layout Paragraph
官方knn的测试程序
\end_layout

\begin_layout Standard
为了学习如何使用该库的k-紧邻搜索功能，我学习了该库关于knn的测试程序。具体地，mlpack官方在src/mlpack/tests目录提供了测试该库很多功能的
一个测试程序。为了便于阅读、管理，我们从其中抽取出了测试knn的部分，存放在项目目录learning/mlpack/knn_test下，在该目录下直接运行bin
/knn_test即可。该程序运行时会访问同样位于该目录的一个测试文件test_data_3_1000.csv。
\end_layout

\begin_layout Paragraph
概述
\end_layout

\begin_layout Standard
该库对类模板NeighborSearch进行实例化，得到一个基于欧氏距离的k-紧邻搜索的类KNN，具体的：
\end_layout

\begin_layout Standard
typedef NeighborSearch<NearestNeighborSort, EuclideanDistance> KNN;
\end_layout

\begin_layout Subsubsection
给定范围的搜索/类模板RangeSearch
\end_layout

\begin_layout Paragraph
文献
\end_layout

\begin_layout Standard
https://en.wikipedia.org/wiki/Range_searching，一般性地介绍Range search。
\end_layout

\begin_layout Standard
https://github.com/mlpack/mlpack/blob/master/doc/tutorials/range_search.md，关于mlpac
k中和range search相关的类模板、程序的说明。
\end_layout

\begin_layout Paragraph
概述
\end_layout

\begin_layout Standard
这是另外一种搜索任务，该任务的描述如下。给定一个距离范围[min,max]，对于一个查询数据集的每个点P，在参考数据集中寻找那些和P点的距离落在上述范围的点。库
mlpack提供了一个类模板RangeSearch来实现这个功能，该类模板的用法和类模板NeighborSearch的类似，本节描述该类模板的用法。
\end_layout

\begin_layout Paragraph
模板参数
\end_layout

\begin_layout Verbatim
template<typename MetricType = EuclideanDistance,
\end_layout

\begin_layout Verbatim
         typename MatType = arma::mat,
\end_layout

\begin_layout Verbatim
         template<typename TreeMetricType,
\end_layout

\begin_layout Verbatim
                  typename TreeStatType,
\end_layout

\begin_layout Verbatim
                  typename TreeMatType> class TreeType = KDTree>
\end_layout

\begin_layout Verbatim
class RangeSearch;
\end_layout

\begin_layout Standard
从模板参数可以看出这个类模板是一个非常灵活的范围搜索器。每个模板参数都有默认值，对于常见的应用，用户可以不指定或者只指定少量的模板参数，就可以使用该类模板。以下
是各个模板参数的含义。
\end_layout

\begin_layout Standard
MetricType。定义如何度量两个点的距离。
\end_layout

\begin_layout Standard
MatType。矩阵类型。要求其API符合armadillo中矩阵类的。一般取arma::mat或者arma::sp_mat。
\end_layout

\begin_layout Standard
TreeType。点的索引树的类型。常见的有KDTree, BallTree, StandardCoverTree, RTree或者RStarTree。默认的是
KDTree。
\end_layout

\begin_layout Paragraph
样例
\end_layout

\begin_layout Verbatim
#include <mlpack.hpp>
\end_layout

\begin_layout Verbatim
using namespace mlpack;
\end_layout

\begin_layout Verbatim
arma::mat data;
\end_layout

\begin_layout Verbatim
RangeSearch<> a(data);
\end_layout

\begin_layout Verbatim
vector<vector<size_t> > resultingNeighbors;
\end_layout

\begin_layout Verbatim
vector<vector<double> > resultingDistances;
\end_layout

\begin_layout Verbatim
Range r(0.0, 2.0); // [0.0, 2.0].
\end_layout

\begin_layout Verbatim
a.Search(r, resultingNeighbors, resultingDistances);
\end_layout

\begin_layout Paragraph
内部定义的类型
\end_layout

\begin_layout Standard
typedef TreeType<MetricType, RangeSearchStat, MatType> Tree;
\end_layout

\begin_layout Paragraph
构造函数
\end_layout

\begin_layout Standard
该类模板提供了多个构造函数，其中参数最大的一个如下：
\end_layout

\begin_layout Verbatim
  RangeSearch(MatType referenceSet,
\end_layout

\begin_layout Verbatim
              const bool naive = false,
\end_layout

\begin_layout Verbatim
              const bool singleMode = false,
\end_layout

\begin_layout Verbatim
              const MetricType metric = MetricType());
\end_layout

\begin_layout Standard
一些参数的含义如下。
\end_layout

\begin_layout Standard
naive。如果为真，则不使用任何索引树来加速搜索，而是使用蛮力（bruce-force）进行穷尽搜索。一般并不会使用这种方式。
\end_layout

\begin_layout Standard
singleMode。当查询数据集中含有多个查询点的时候，使用一个名字为dual-tree的技术可以获得更快的查询速度。该参数为false的时候启用dual-t
ree技术，为真的时候禁用该技术。
\end_layout

\begin_layout Paragraph
搜索
\end_layout

\begin_layout Standard
该类模板提供了一组搜索函数，常用的一个如下：
\end_layout

\begin_layout Verbatim
void Search(const MatType& querySet,
\end_layout

\begin_layout Verbatim
            const Range& range,
\end_layout

\begin_layout Verbatim
            vector<vector<size_t>>& neighbors,
\end_layout

\begin_layout Verbatim
            vector<vector<double>>& distances);
\end_layout

\begin_layout Standard
一些参数的含义如下。
\end_layout

\begin_layout Standard
querySet。查询数据集，矩阵的每列表示一个查询点。这个数据集可以是参考数据集本身。
\end_layout

\begin_layout Standard
neighbors。该容器元素个数和querySet中的列数是相等的，第i个元素存放第i个查询点对应的、符合查询条件的参考点的索引。对各个查询点，满足搜索条件的
参考点的数量可能不同，所以我们需要使用vector<vector<...>>而不是矩阵来存放搜索结果。这些参考点并没有依据任何标准被排序。
\end_layout

\begin_layout Standard
distances。该容器元素个数和querySet中的列数是相等的，第i个元素存放第i个查询点对应的、与那些符合查询条件的参考点的距离。
\end_layout

\begin_layout Subsubsection
类模板DBSCAN<>
\end_layout

\begin_layout Standard
该类模板实现dbscan算法，本节描述该类模板的用法。
\end_layout

\begin_layout Paragraph
样例
\end_layout

\begin_layout Standard
以下样例取自该库的测试程序（src/mlpack/tests/dbscan_test.cpp）。
\end_layout

\begin_layout Verbatim
  arma::mat points(2, 200, arma::fill::randu);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
  // Add 3 outliers.
\end_layout

\begin_layout Verbatim
  points.col(15) = arma::vec("10.3 1.6");
\end_layout

\begin_layout Verbatim
  points.col(45) = arma::vec("-100 0.0");
\end_layout

\begin_layout Verbatim
  points.col(101) = arma::vec("1.5 1.5");
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
  DBSCAN<> d(0.1, 3);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
  arma::Row<size_t> assignments;
\end_layout

\begin_layout Verbatim
  const size_t clusters = d.Cluster(points, assignments);
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
  REQUIRE(clusters > 0);
\end_layout

\begin_layout Verbatim
  REQUIRE(assignments.n_elem == points.n_cols);
\end_layout

\begin_layout Verbatim
  REQUIRE(assignments[15] == SIZE_MAX);
\end_layout

\begin_layout Verbatim
  REQUIRE(assignments[45] == SIZE_MAX);
\end_layout

\begin_layout Verbatim
  REQUIRE(assignments[101] == SIZE_MAX);
\end_layout

\begin_layout Paragraph
模板参数
\end_layout

\begin_layout Verbatim
template<typename RangeSearchType = RangeSearch<>,
\end_layout

\begin_layout Verbatim
         typename PointSelectionPolicy = OrderedPointSelection>
\end_layout

\begin_layout Verbatim
class DBSCAN{...}
\end_layout

\begin_layout Standard
各个参数的说明如下。
\end_layout

\begin_layout Standard
RangeSearchType。一般是前文的类模板RangeSearch实例化后的一个类。
\end_layout

\begin_layout Standard
PointSelectionPolicy。在处理完毕参考数据集中一个点后，选择下一个点的策略。
\end_layout

\begin_layout Paragraph
构造函数
\end_layout

\begin_layout Verbatim
DBSCAN(const double epsilon,
\end_layout

\begin_layout Verbatim
       const size_t minPoints,
\end_layout

\begin_layout Verbatim
       const bool batchMode = true,
\end_layout

\begin_layout Verbatim
       RangeSearchType rangeSearch = RangeSearchType(),
\end_layout

\begin_layout Verbatim
       PointSelectionPolicy pointSelector = PointSelectionPolicy());
\end_layout

\begin_layout Standard
各个参数的说明如下。
\end_layout

\begin_layout Standard
epsilon。dbscan算法中的Eps。
\end_layout

\begin_layout Standard
minPoints。dbscan算法中的MinPts。
\end_layout

\begin_layout Standard
batchMode。如果为真，所有被聚类的点被放置在内存。对于本项目，由于一帧的点云图数据量并不大，令该参数为真。
\end_layout

\begin_layout Paragraph
聚类操作
\end_layout

\begin_layout Standard
提供了一组成员函数，它们输出的信息不同。
\end_layout

\begin_layout Verbatim
template<typename MatType>
\end_layout

\begin_layout Verbatim
size_t Cluster(const MatType& data, arma::Row<size_t>& assignments,
\end_layout

\begin_layout Verbatim
               arma::mat& centroids);
\end_layout

\begin_layout Standard
对矩阵data中的点进行聚类，矩阵的一列表示一个点。每个点所属簇的ID信息被输出到参数assignments中。如果这个ID为SIZE_MAX，则对应的点被认为
是噪音。各个簇的质心被返回在centroids中。函数返回簇的个数。
\end_layout

\begin_layout Standard
和以下的函数相比，这个函数返回的信息最完整。
\end_layout

\begin_layout Verbatim
template<typename MatType>
\end_layout

\begin_layout Verbatim
  size_t Cluster(const MatType& data, arma::Row<size_t>& assignments);
\end_layout

\begin_layout Standard
对矩阵data中的点进行聚类，矩阵的一列表示一个点。每个点所属簇的ID信息被输出到参数assignments中。如果这个ID为SIZE_MAX，则对应的点被认为
是噪音。函数返回簇的个数。
\end_layout

\begin_layout Verbatim
template<typename MatType>
\end_layout

\begin_layout Verbatim
size_t Cluster(const MatType& data, arma::mat& centroids);
\end_layout

\begin_layout Standard
对矩阵data中的点进行聚类，矩阵的一列表示一个点。各个簇的质心被返回在centroids中。函数返回簇的个数。
\end_layout

\begin_layout Subsection
Boost.Geometry
\end_layout

\begin_layout Standard
基于DBSCAN的聚类曾想使用该库，但是后来觉得这个库被过度设计，用起来不方便，被弃用。
\end_layout

\begin_layout Subsubsection
文献
\end_layout

\begin_layout Standard
https://www.boost.org/doc/libs/1_83_0/libs/geometry/doc/html/index.html。
\end_layout

\begin_layout Subsubsection
接口
\end_layout

\begin_layout Standard
作为boost库的一部分发布，因而该库的接口由整体boost库的决定。
\end_layout

\begin_layout Standard
要求。编译器启用C++ 14支持。
\end_layout

\begin_layout Standard
头文件。位于/usr/include/boost/geometry。常用的两个头文件如下：
\end_layout

\begin_layout Standard
geometries/geometries.hpp。其中包含一些基本的几何概念的定义。用户一般应该包含这个文件。只有用户希望自己定义这些基本概念时，才不会包含该文
件，而是去包含自己的定义了基本几何概念的头文件。
\end_layout

\begin_layout Standard
geometry.hpp。包括了除了上面这个头文件及其所要包含的头文件以外的该库的所有其他头文件。用户一般通过包含这个头文件来使用该库，而不是自行包含该库子模块对
应的头文件，因为后面这些头文件的名字在该库演化时可能会变化。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
名字空间。boost::geometry。
\end_layout

\begin_layout Subsubsection
概述
\end_layout

\begin_layout Standard
官网。虽然是Boost库的一部分，但是该库有自己的官网，为https://github.com/boostorg/geometry。从它可以下载库文档、样例等。
\end_layout

\begin_layout Standard
是boost中的一个纯头文件库。设计目标是一个通用的几何运算的库，目标应用领域是地图、GIS系统、游戏、计算机图形学、机器人等。目前用的最多的是GIS系统。该库
定义了几何学中的概念、源语，并在此基础上实现了常见的几何算法，例如面积、长度、周长、质心、凸包、包含、距离等等。
\end_layout

\begin_layout Standard
设计理念。该库试图实现最大程度的通用性。为了达到这个目的，大量使用C++模板以及关联技术（比如tag dispatching）。这个文档中的Design
 Rationale部分介绍了库的设计思路。这部分内容难懂，普通用户无需阅读这部分。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
个人印象。由于上述设计理念，该库灵活但是用法复杂。使用中用户会频繁的分心到那些自己不会用到的功能以及抽象。总体上觉得它并不好用。
\end_layout

\begin_layout Subsubsection
2D空间的几何体
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
点
\end_layout

\begin_layout Standard
该库提供了多种方式来表示一个空间上的点。
\end_layout

\begin_layout Subparagraph
point<>
\end_layout

\begin_layout Standard
model::point<typename CoordinateType, std::size_t DimensionCount, typename
 CoordinateSystem>。
\end_layout

\begin_layout Standard
这个类模板表示一个坐标系中立（coordinate system neutral）的点。模板参数的含义如它们的名字所示。
\end_layout

\begin_layout Standard
头文件。<boost/geometry/geometries/point.hpp> 
\end_layout

\begin_layout Standard
构造函数。提供了一维，二维，三维空间的点的构造函数，但是没有提供更高维度的。
\end_layout

\begin_layout Standard
坐标分量的访问。以模板函数的形式呈现，也就是：
\end_layout

\begin_layout Standard
template<std::size_t K>
\end_layout

\begin_layout Standard
constexpr CoordinateType const & get()
\end_layout

\begin_layout Standard
template<std::size_t K>
\end_layout

\begin_layout Standard
void set(CoordinateType const & value)
\end_layout

\begin_layout Standard
一个例子：
\end_layout

\begin_layout Verbatim
#include <boost/geometry.hpp>
\end_layout

\begin_layout Verbatim
#include <boost/geometry/geometries/point.hpp> 
\end_layout

\begin_layout Verbatim
namespace bg = boost::geometry;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
int main()
\end_layout

\begin_layout Verbatim
{
\end_layout

\begin_layout Verbatim
    bg::model::point<double, 2, bg::cs::cartesian> point1;
\end_layout

\begin_layout Verbatim
    bg::model::point<double, 3, bg::cs::cartesian> point2(1.0, 2.0, 3.0); 
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
    point1.set<1>(2.0); 
\end_layout

\begin_layout Verbatim
    point1.get<1>();
\end_layout

\begin_layout Verbatim
}
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subparagraph
point_xy<>
\end_layout

\begin_layout Standard
model::d2::point_xy<T> ，其中的T为点的坐标的数据类型。
\end_layout

\begin_layout Standard
头文件。<boost/geometry/geometries/point_xy.hpp>
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subparagraph
将boost::tuple看做一个点
\end_layout

\begin_layout Standard
一个二元组可以被看做一个点。
\end_layout

\begin_layout Standard
#include <boost/geometry/geometries/adapted/boost_tuple.hpp>
\end_layout

\begin_layout Standard
boost::tuple<double, double> p = boost::make_tuple(3.7, 2.0);
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subparagraph
将C数组看做一个点
\end_layout

\begin_layout Standard
可以将含有两个元素的普通C数组看做一个点，例如：
\end_layout

\begin_layout Standard
#include <boost/geometry/geometries/adapted/c_array.hpp>
\end_layout

\begin_layout Standard
int a[2] = {1,1};
\end_layout

\begin_layout Standard
int b[2] = {2,3};
\end_layout

\begin_layout Standard
double d = distance(a, b);
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
多边形
\end_layout

\begin_layout Standard
#include <boost/geometry/geometries/polygon.hpp>
\end_layout

\begin_layout Standard
一个例子：
\end_layout

\begin_layout Standard
double points[][2] = {{2.0, 1.3}, {4.1, 3.0}, {5.3, 2.6}, {2.9, 0.7}, {2.0, 1.3}};
\end_layout

\begin_layout Standard
model::polygon<model::d2::point_xy<double> > poly;
\end_layout

\begin_layout Standard
append(poly, points);
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
距离
\end_layout

\begin_layout Standard
distance(point1, point2)。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
面积
\end_layout

\begin_layout Standard
可以计算诸多几何元素的面积，常用的一些如下。
\end_layout

\begin_layout Standard
area(polygon)。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
几何元素的位置关系
\end_layout

\begin_layout Standard
判断一个点是否落在一个多边形内部。
\end_layout

\begin_layout Standard
within(point, polygon)。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
R-tree介绍
\end_layout

\begin_layout Paragraph
文献
\end_layout

\begin_layout Standard
https://en.wikipedia.org/wiki/R-tree，介绍R-tree。
\end_layout

\begin_layout Standard
https://en.wikipedia.org/wiki/R*-tree
\end_layout

\begin_layout Paragraph
概述
\end_layout

\begin_layout Standard
该库，DBSCAN的原论文以及下文的YgorClustering库都用到R-tree，我们需要学习其原理。
\end_layout

\begin_layout Standard
R-tree是针对空间/地理数据集的。为方便称述，下文只讨论2D情形。在这些数据集上，一个数据项被表示为一个点（比如一个建筑物的坐标）或者一个矩形（比如一个单位
的范围）。为讨论方便，我们将点看做区域的特例。在这些应用中，一个常见的操作是基于距离的查询，例如，在一个表示城市地图的数据集中，我们想要查询“距离我最近的加油站
在哪里”。为了能够加快查询，我们需要对数据进行适当的组织。R-tree就是这样的一个数据结构。
\end_layout

\begin_layout Standard
R-tree的基本思路是，使用矩形框作为检索依据（R-tree名字中的R表示此处的Rectangle），使用多叉树来组织数据。读者可以结合下图来理解其思路。图中
，实框表示数据项，虚框表示算法构建出来的矩形框。一个树节点最多存放M个矩形框。根节点最少可以只存放一个框，但是要求其他节点至少存放K个矩形框（K>1）。每个虚框
指向一个子树，该子树的根节点是该虚框所直接包含的框。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/R-tree-example.png

\end_inset


\end_layout

\begin_layout Standard
R-tree的查询。对R-tree的查询都会利用以下事实来加速查询速度：给定一个目标区域，从树的根节点出发，如果一颗子树对应的最外层的框不包含目标区域，则这颗子
树可以被略过。查询算法只需要关注那些可能含有该目标区域的子树。
\end_layout

\begin_layout Standard
R-tree的构建。这是该数据结构的难点。其目标一方面是保证树是平衡的，另一方面需要尽量缩减框中空白区域的面积以及框之间的重叠面积（因而能减少查询所涉及的子树的
数量）。有多种算法，该库文档中给出了4种算法的性能比较，如下图：
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/rtree_construct_algorithms.png

\end_inset


\end_layout

\begin_layout Standard
聚类对象是1百万个随机生成的二维矩形框，左图是树的构建时间，右图是执行100k次查询的时间。可以看到，传统的R*算法虽然查询性能次优，但是其构建时间最长。而pa
cking algorithm在构建以及查询方面都是最优的。
\end_layout

\begin_layout Paragraph
R*-tree
\end_layout

\begin_layout Standard
是R-tree的一个变体。和R-tree的不同主要是树的构建。它采用了更加复杂的算法，虽然构建过程会变慢，但是之后的树的查询速度会变快。该算法所生成的树的框之间
的重叠程度，以及框所覆盖的空白区域面积，都会更小。一个例子如下图，图中的数据（实框）为德国的邮政区域。左边为R*-tree对应的所有框，右边为普通R-tree的
所有框。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/R-start-tree-example.png

\end_inset


\begin_inset Graphics
	filename figures/R-tree-rectanges.png

\end_inset


\end_layout

\begin_layout Paragraph
Boost.geometry的R-tree实现
\end_layout

\begin_layout Standard
该库含有R-tree的四种实现，其中有R*-tree以及packing algorithm。被聚类的点的类型是模板参数，因而支持任意的用户类型。含有k-紧邻搜索
功能。以迭代器的形式返回查询结果。
\end_layout

\begin_layout Subsubsection
该库的R-tree API
\end_layout

\begin_layout Paragraph
样例
\end_layout

\begin_layout Standard
被聚类的点的类型是一个模板参数，因而可以是任意类型。本样例中被处理的点位于二维空间，该模板参数的一个可能的取值为
\end_layout

\begin_layout Standard
std::pair<Box, MyGeometryId>，
\end_layout

\begin_layout Standard
其中的Box表示矩形框，而MyGeometryId是用户为每个矩形框指定的一个ID的类型。
\end_layout

\begin_layout Standard
定义一个R-tree的示意代码如下。
\end_layout

\begin_layout Verbatim
#include <boost/geometry.hpp>
\end_layout

\begin_layout Verbatim
#include <boost/geometry/geometries/point.hpp>
\end_layout

\begin_layout Verbatim
#include <boost/geometry/geometries/box.hpp>
\end_layout

\begin_layout Verbatim
#include <boost/geometry/index/rtree.hpp>
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
namespace bg = boost::geometry;
\end_layout

\begin_layout Verbatim
namespace bgi = boost::geometry::index;   // R-tree对应的名字空间
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
typedef bg::model::point<float, 2, bg::cs::cartesian> point;
\end_layout

\begin_layout Verbatim
typedef bg::model::box<point> box;
\end_layout

\begin_layout Verbatim
typedef std::pair<box, unsigned> value;
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
bgi::rtree<value, bgi::quadratic<16> > rtree;   // 第二个模板参数指定树的构建算法
\end_layout

\begin_layout Standard
用户通过多次向树中添加叶节点来构建树：
\end_layout

\begin_layout Verbatim
for ( unsigned i = 0 ; i < 10 ; ++i ){
\end_layout

\begin_layout Verbatim
    box b(point(i + 0.0f, i + 0.0f), point(i + 0.5f, i + 0.5f));
\end_layout

\begin_layout Verbatim
    rtree.insert(std::make_pair(b, i));
\end_layout

\begin_layout Verbatim
}
\end_layout

\begin_layout Standard
rtree提供了一个query()成员模板函数来执行查询，示意代码如下：
\end_layout

\begin_layout Verbatim
// find values intersecting some area defined by a box
\end_layout

\begin_layout Verbatim
box query_box(point(0, 0), point(5, 5));
\end_layout

\begin_layout Verbatim
std::vector<value> result_s;
\end_layout

\begin_layout Verbatim
rtree.query(bgi::intersects(query_box), std::back_inserter(result_s));
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim
// find 5 nearest values to a point
\end_layout

\begin_layout Verbatim
std::vector<value> result_n;
\end_layout

\begin_layout Verbatim
rtree.query(bgi::nearest(point(0, 0), 5), std::back_inserter(result_n));
\end_layout

\begin_layout Subsection
YgorClustering
\end_layout

\begin_layout Subsubsection
安装
\end_layout

\begin_layout Standard
这是一个纯头文件库，并不需要编译链接。即使如此，该包也提供了一个安装脚本compile_and_install.sh，用户执行该脚本就可以安装。
\end_layout

\begin_layout Subsubsection
接口
\end_layout

\begin_layout Standard
头文件。位于/usr/include，一组以YgorCluster打头的文件。
\end_layout

\begin_layout Subsubsection
估计算法参数Eps以及MinPts
\end_layout

\begin_layout Standard
该库提供了以下函数用于生成原论文中的k-dist曲线，通过该曲线，用户可以确定算法参数Eps。
\end_layout

\begin_layout Verbatim
template < typename RTree_t, //A Boost.Geometry R*-tree, specifically.
\end_layout

\begin_layout Verbatim
           typename ClusteringDatum_t >
\end_layout

\begin_layout Verbatim
vector<typename ClusteringDatum_t::SpatialType_>
\end_layout

\begin_layout Verbatim
DBSCANSortedkDistGraph( RTree_t & RTree, size_t k = ClusteringDatum_t::SpatialDi
mensionCount_ * 2 )
\end_layout

\begin_layout Standard
各个模板参数的含义：
\end_layout

\begin_layout Standard
Rtree_t。可以为Boost.Geometry中表示R*树的类型。
\end_layout

\begin_layout Standard
ClusteringDatum_t。被聚类的一个点的类型，参下文的ClusteringDatum。
\end_layout

\begin_layout Subsubsection
类模板ClusteringDatum<>
\end_layout

\begin_layout Standard
该类模板表示输入数据中一个点的信息。利用C++的模板机制，通过该类模板的模板参数，该类模板可以表示多种类型的点。以下是该类的模板参数：
\end_layout

\begin_layout Verbatim
class ClusteringUserDataEmptyClass{};
\end_layout

\begin_layout Verbatim
template < 
\end_layout

\begin_layout Verbatim
    size_t SpatialDimensionCount,
\end_layout

\begin_layout Verbatim
    typename SpatialType,
\end_layout

\begin_layout Verbatim
    size_t AttributeDimensionCount, 
\end_layout

\begin_layout Verbatim
    typename AttributeType,
\end_layout

\begin_layout Verbatim
    typename ClusterIDType = uint32_t,
\end_layout

\begin_layout Verbatim
    typename UserDataClass = ClusteringUserDataEmptyClass >>     
\end_layout

\begin_layout Verbatim
class ClusteringDatum{...}
\end_layout

\begin_layout Standard
各个模板参数的说明如下。
\end_layout

\begin_layout Standard
SpatialDimensionCount。点的坐标的维数。对于本项目，该参数应该为3。
\end_layout

\begin_layout Standard
SpatialType。点的坐标的数据类型。对于本项目，由于pcl库使用float表示点的坐标分量，我们令该参数取float。
\end_layout

\begin_layout Standard
AttributeDimensionCount。该库允许用户在一个点中附属额外属性信息。这个信息被该类模板表示为一个一维数组，本模板参数指定这个数组的长度。
\end_layout

\begin_layout Standard
AttributeType。属性数组中每个元素的数据类型。
\end_layout

\begin_layout Standard
ClusterIDType。簇编号的数据类型。本项目中，对于1024*768的一幅图像，像素点（也是点云图中的点的最大个数）是78万个。即使点云图中的每个点自成
一个簇，默认的uint32_t也可以描述这个数量。而uint16_t则不可以。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
本项目中的点的附属信息。YgorClustering库被设计为能够处理任意类型的点，并不是只能够处理pcl库中的点。为了能够使用该库，需要将pcl库中的点云数据
复制过来。这个过程中，为了维护聚类中的点和pcl点云中的点的对应关系，我们需要将点云中点的索引作为ClusteringDatum的附属属性信息。这样，当Ygor
Clutering库执行聚类时，一个点在pcl点云中的索引信息会被一致保留。
\end_layout

\begin_layout Section
从深度图计算点云图
\end_layout

\begin_layout Standard
这个章节中的工作在开发过程中曾经有用，现在无需关注这个章节。
\end_layout

\begin_layout Subsection
文献
\end_layout

\begin_layout Standard
https://pointclouds.org/documentation/classpcl_1_1_disparity_map_converter.html#de
tails，pcl库的函数。
\end_layout

\begin_layout Standard
https://github.com/ethz-asl/maplab/blob/master/algorithms/dense-reconstruction/st
ereo-dense-reconstruction/src/disparity-conversion-utils.cpp）。双目视差转换为点云或者深度的代码
\end_layout

\begin_layout Subsection
概述
\end_layout

\begin_layout Standard
KITTI的深度真值数据集（参前文）提供了计算好的视差（深度）数据。而环境感知中需要的是以点云图格式表示的若干物理点的三维坐标信息。这个需要一些计算，计算原理参
计算机视觉学习笔记中的“3D重建/立体视觉”部分。
\end_layout

\begin_layout Subsection
使用H5格式来存放被处理数据
\end_layout

\begin_layout Standard
KITTI的真值深度信息原本以KITTI约定的存放形式存放在Depth以及RAW两个数据集中。为了便于转换程序处理，我们先将这些数据存放为H5格式。以下是关于该
H5文件的一些信息。
\end_layout

\begin_layout Subsubsection
H5文件设计原则
\end_layout

\begin_layout Standard
HDF5文件中目录的设计原则：
\end_layout

\begin_layout Standard
-这个HDF5文件本质是KITTI Depth以及RAW中部分数据的索引，而不是数据本身。该文件不会重复存放被索引数据集中的数据。
\end_layout

\begin_layout Standard
-使用自行定义的序列ID、帧序号来唯一地标识一帧。
\begin_inset space \space{}
\end_inset

序列ID的格式为“seq_x”，其中x是序列的自然编号。序列ID不像KITTI中的驾次ID那样蕴涵有其他信息，简单而容易记忆。
\end_layout

\begin_layout Standard
-将那些和帧对应的数据称为主数据，其他数据称为辅助数据。这两个部分分开存放，然后在每个帧的数据中添加一个逻辑上的指针，指向关联的辅助数据。例如，KITTI的相机
校准数据是逐天进行的，我们会令某一天录制的所有帧的数据中都有一个这样的指针，指向那天的相机校准数据。这样做虽然看起来有些数据冗余，但是便于编程。
\end_layout

\begin_layout Standard
-图像数据不会被存放在HDF5文件中，而是只会存放图像文件在操作系统文件系统中的相对路径。这样做的原因：图像数据本身是经过压缩处理的，而且，这个压缩比一般较大，
例如png格式的压缩比是4~10。如果将图像转换为Tensor存放，其容量会大幅增加，不利于大数据集的处理。
\end_layout

\begin_layout Standard
- 只针对具体任务设计HDF5文件中的目录结构，而不是试图涵盖KITTI的所有数据。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
- 每个数据项的类型应该是h5pp库支持的，因而可以直接使用h5pp加载、保存这些数据而无需额外转换。
\end_layout

\begin_layout Subsubsection
H5文件目录结构
\end_layout

\begin_layout Standard
依据上述原则，保存KITTI真值深度数据的HDF5文件的目录结构如下。
\end_layout

\begin_layout Verbatim
sequenceNumber            # Depth数据集中总的序列（驾次）的数目。
\end_layout

\begin_layout Verbatim
seq_n                     # 序列n的数据
\end_layout

\begin_layout Verbatim
    kittiSequenceID       # 类型为string，是该序列在KITTI数据集中的序列标识，一个例子：
\end_layout

\begin_layout Verbatim
                          # 2011_09_26_drive_0001_sync
\end_layout

\begin_layout Verbatim
                          # 依据这个标识，能够找到该序列的其他所有信息，例如对应的场景名。
\end_layout

\begin_layout Verbatim
                          # 由于这个原因，本H5文件不再存放一个序列的其他关联信息。
\end_layout

\begin_layout Verbatim
    leftDepths            # 类型为vector<string>，第k个元素存放第k帧的深度图的相对路径。例如：
\end_layout

\begin_layout Verbatim
                          # kittiDepth/train/2011_10_03_drive_0042_sync/proj_dep
th/ground truth/
\end_layout

\begin_layout Verbatim
                          #   image_02/0000001164.png
\end_layout

\begin_layout Verbatim
    leftImages            # 类型为vector<string>，第k个元素存放第k帧的左目相机的图像的相对路径。例如：
\end_layout

\begin_layout Verbatim
                          # kittiRaw/Road/2011_10_03/2011_10_03_drive_0042_sync/
image_02/
\end_layout

\begin_layout Verbatim
                          #   data/0000001164.png
\end_layout

\begin_layout Verbatim
                          # 上述两个数据项的元素个数就是序列的帧数，应该是相等的。
\end_layout

\begin_layout Verbatim
    cameraCalibration     # 该目录存放所有录制该序列的那天的相机校准数据
\end_layout

\begin_layout Verbatim
                          # 其中的数据在同一天录制的所有序列中是重复存放的，但是，由于被存放的数据的容量很小，
\end_layout

\begin_layout Verbatim
                          # 这个并不会造成大的问题。
\end_layout

\begin_layout Verbatim
        left_P_rect       # 类型为一个eigen::Matrix，形状为3x4，是左目相机的射影矩阵。
\end_layout

\begin_layout Verbatim
                          # 由于深度到点云转换只用到这个矩阵，我们并没有存放其他校准数据。
\end_layout

\begin_layout Standard
将整个文件命名为depth.hdf5。
\end_layout

\begin_layout Subsubsection
程序generateDepthHDF5
\end_layout

\begin_layout Standard
程序位于kittiDepthToPointCloudMap/generateDepthHDF5。用户在本地执行upload.fish，将程序、相关脚本上传到sw机
器，然后，登录sw机器，进入到/sw/obstacleAvoidance/kittiDepthToPointCloudMap/generateDepthHDF5
目录，运行其中的run脚本程序即可。
\end_layout

\begin_layout Standard
共有149个序列被处理。
\end_layout

\begin_layout Subsection
程序实现/depthToPointCloudMap
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
pcl库提供了这方面的功能，我们使用该库。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
深度到视差的转换。深度就是学习笔记的“三角测量法获得物理点的坐标”部分中的
\begin_inset Formula $z_{s}$
\end_inset

，而视差就是该部分的
\begin_inset Formula $x_{L}-x_{R}$
\end_inset

，读者必须要复习这个部分才能够理解二者的关系。佐证这个事实的一个网文是https://stackoverflow.com/questions/61053294/w
hat-is-difference-between-disparity-and-depth。
\end_layout

\begin_layout Standard
一般的点云图的计算流程是从视差计算体素的深度
\begin_inset Formula $z_{s}$
\end_inset

以及
\begin_inset Formula $x_{s},y_{s}$
\end_inset

信息。不过，KITTI的深度真值数据集的数据中存放的是深度而不是视差信息。而pcl库的类模板DisparityMapConverter<PointT>要求输入是
视差。我们需要先将其转换回视差信息，然后才能使用pcl库计算出体素的三维坐标信息
\begin_inset Formula $(x_{s},y_{s},z_{s})$
\end_inset

。给定立体相机的配置参数，二者之间是可以相互推算的，转换的原理很简单。依据学习笔记，有
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
z_{s}=\frac{b\cdot f}{x_{L}-x_{R}}.
\]

\end_inset


\end_layout

\begin_layout Standard
其中
\begin_inset Formula $b$
\end_inset

是两个相机之间的间距，
\begin_inset Formula $f$
\end_inset

是相机的焦距，都是常量，所以，能够很容易从深度求解出视差，也就是
\begin_inset Formula 
\begin{equation}
x_{L}-x_{R}=\frac{b\cdot f}{z_{s}}.\label{eq:depth_to_disparity}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
上述参数
\begin_inset Formula $b$
\end_inset

的值。从其文档kittiRaw/devkit/readme.txt知道，彩色双目相机的baseline（相机间距）为0.54m。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
关于
\begin_inset Formula $z_{s}$
\end_inset

的单位。为米，详情参KITTI Depth数据集的说明部分。
\end_layout

\begin_layout Subsubsection
关于上述参数
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Standard
由于我们所使用的数据是KITTI官方针对相机系统的各种畸变校准之后的数据，所以并不能使用物理相机的焦距。依据@vmr-13，我们应该使用式（4）中
\begin_inset Formula $P_{rect}$
\end_inset

矩阵中的
\begin_inset Formula $f_{u}$
\end_inset

或者
\begin_inset Formula $f_{v}$
\end_inset

。上述两个量分别表示
\begin_inset Formula $x/y$
\end_inset

方向上的焦距（我尚不明白这两个量的含义，以及为何需要有两个焦距，不过，二者应该是相等的）。该矩阵的一个例子（数值被简化）如下：
\begin_inset Formula 
\[
\begin{bmatrix}721 & 0 & 609 & 44\\
0 & 721 & 172 & 0.216\\
0 & 0 & 1 & 0.002
\end{bmatrix}.
\]

\end_inset


\end_layout

\begin_layout Standard
依据@vmr-13式（4），一些基本量和上述矩阵坐标的对应关系是：
\begin_inset Formula $f_{u}:(1,1)$
\end_inset

，
\begin_inset Formula $f_{v}:(2,2)$
\end_inset

，
\begin_inset Formula $c_{u}:(1,3)$
\end_inset

，
\begin_inset Formula $c_{v}:(2,3)$
\end_inset

，其中，
\begin_inset Formula $(c_{u},v_{v})$
\end_inset

是以图像中心为坐标原点到以图像左上角为坐标原点时的那个变换中的
\begin_inset Formula $x/y$
\end_inset

方向上的偏移量。
\end_layout

\begin_layout Standard
得出这个结论的依据。是该论文引用的@aca-12，以及后者引用的@afc-97。实际上，关于这点@aca-12还引用了另外两篇文献，在该论文中的文献编号是[1,
6]。其中[1]的网址为 http://www.vision.caltech.edu/bouguetj/calib_doc。这是matlab中一个工具箱的文档，其论述
中使用matlab变量名而不是数学符号，所以阅读起来有些困难。而[6]是一本书，难以从这么长的篇幅中找到答案。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
关于参数
\begin_inset Formula $f$
\end_inset

的单位。理想情况下，我们希望焦距的单位是mm，但是依据https://stackoverflow.com/questions/45316427/what-are-
the-focal-lengths-and-the-principal-point-in-kitti-stereo-dataset指出的@vmr-13作者的一个
开源项目（https://github.com/pangfumin/libviso2/blob/master/src/demo.cpp~）中的部分代码：
\end_layout

\begin_layout Verbatim
	// calibration parameters for sequence 2010_03_09_drive_0019
\end_layout

\begin_layout Verbatim
	param.calib.f = 645.24; // focal length in pixels
\end_layout

\begin_layout Verbatim
	param.calib.cu = 635.96; // principal point (u-coordinate) in pixels
\end_layout

\begin_layout Verbatim
	param.calib.cv = 194.13; // principal point (v-coordinate) in pixels
\end_layout

\begin_layout Verbatim
	param.base = 0.5707; // baseline in meters
\end_layout

\begin_layout Standard
这个单位是像素，这个单位到mm的转换公式如下：
\end_layout

\begin_layout Standard
F(mm) = F(pixels) * SensorWidth(mm) / ImageWidth (pixel).
\end_layout

\begin_layout Standard
如果要做这个转换，需要知道相机的光学传感器的宽度。幸运的是，观察式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:depth_to_disparity"

\end_inset

，我们并不需要做这个转换：如果这个式子中
\begin_inset Formula $f$
\end_inset

的单位为像素，计算所得的
\begin_inset Formula $x_{L}-x_{R}$
\end_inset

的单位也是像素。类似地，在计算
\begin_inset Formula $x_{s},y_{s},z_{s}$
\end_inset

的式子中，如果
\begin_inset Formula $x_{L}-x_{R}$
\end_inset

的单位是像素，
\begin_inset Formula $f$
\end_inset

的单位是像素，则计算结果的单位刚好就是米。由于这个原因，KITTI在相机校准结果文件（各个calib_cam_to_cam.txt文件）中给得出的
\begin_inset Formula $f$
\end_inset

的单位都是像素。
\end_layout

\begin_layout Standard
类似的，
\begin_inset Formula $c_{u},c_{v}$
\end_inset

的单位也是像素。
\end_layout

\begin_layout Subsubsection
单帧的处理
\end_layout

\begin_layout Standard
该程序的早期版本只处理单帧数据，测试数据位于该项目的testData目录下。
\end_layout

\begin_layout Paragraph
单帧测试数据
\end_layout

\begin_layout Standard
深度图。kittiDepth/train/2011_10_03_drive_0042_sync/proj_depth/ground truth/image_02
/0000001164.png，被命名为depth.png。
\end_layout

\begin_layout Standard
RGB彩色图像。kittiRaw/Road/2011_10_03/2011_10_03_drive_0042_sync/image_02/ data/00000
01164.png，被命名为rgbColor.png。
\end_layout

\begin_layout Standard
相机校准文件。kittiRaw/Road/2011_10_03/calib_cam_to_cam.txt。该程序中所使用的相机参数来源于该文件中的以下部分：
\end_layout

\begin_layout Verbatim
P_rect_02: 
\end_layout

\begin_layout Verbatim
7.188560e+02 0.000000e+00 6.071928e+02 4.538225e+01 
\end_layout

\begin_layout Verbatim
0.000000e+00 7.188560e+02 1.852157e+02 -1.130887e-01
\end_layout

\begin_layout Verbatim
0.000000e+00 0.000000e+00 1.000000e+00 3.779761e-03
\end_layout

\begin_layout Paragraph
单帧处理结果
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/depth_to_point_cloud.png
	lyxscale 80

\end_inset


\end_layout

\begin_layout Subsubsection
输出数据集的格式
\end_layout

\begin_layout Standard
如前文所述，为了便于后续其他程序对生成的数据集的处理，我们使用H5格式。另一方面，对于输出的点云图数据，为了便于使用ccViewer查看，我们仍然将它们存放为单
独的文件，令H5文件中存放这些文件的路径作为它们的索引，而不是在H5文件中直接存放它们。H5文件的目录结果如下。
\end_layout

\begin_layout Verbatim
sequenceNumber            # 数据集中总的序列（驾次）的数目。
\end_layout

\begin_layout Verbatim
seq_n                     # 序列n的数据
\end_layout

\begin_layout Verbatim
    kittiSequenceID       # 类型为string，是该序列在KITTI数据集中的序列标识，一个例子：
\end_layout

\begin_layout Verbatim
                          # 2011_09_26_drive_0001_sync
\end_layout

\begin_layout Verbatim
                          # 依据这个标识，能够找到该序列的其他所有信息，例如对应的场景名。
\end_layout

\begin_layout Verbatim
                          # 由于这个原因，本H5文件不再存放一个序列的其他关联信息。
\end_layout

\begin_layout Verbatim
    pointClouds           # 类型为vector<string>，第k个元素存放第k帧的点云图文件的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/exp/pointCloud/seq_100/frame_34.ply
\end_layout

\begin_layout Verbatim
                          # 文件名中帧的编号是k+5(因为k=0的那帧是实际录制中的第5帧)
\end_layout

\begin_layout Verbatim
	leftImages            # 类型为vector<string>，第k个元素存放第k帧的左目相机的图像的路径。例如：
\end_layout

\begin_layout Verbatim
                          # kittiRaw/Road/2011_10_03/2011_10_03_drive_0042_sync/
image_02/
\end_layout

\begin_layout Verbatim
                          #   data/0000001164.png
\end_layout

\begin_layout Verbatim
                          # 上述两个数据项的元素个数就是序列的帧数，应该是相等的。
\end_layout

\begin_layout Subsubsection
程序用法
\end_layout

\begin_layout Standard
为了能够在sw机器上远程执行该程序，开发者需要做以下操作：
\end_layout

\begin_layout Standard
1.
 上传可执行文件以及相关数据文件。完成该操作的脚本程序是/sw/obstacleAvoidance/kittiDepthToPointCloudMap/dept
hToPointCloudMap/upload.fish。
\end_layout

\begin_layout Standard
2.
 在sw机器的/sw/obstacleAvoidance/kittiDepthToPointCloudMap/depthToPointCloudMap执行run
。该程序的一些参数的解释如下：
\end_layout

\begin_layout Standard
--depthH5Filename。指定输入H5文件，其中存放KITTI真值深度数据集。
\end_layout

\begin_layout Standard
--pointCloudDir。指定输出目录，该目录下会生成一个pointCloud.h5，是前文的那个H5文件。另外，还会生成若干seq_n目录，其中存放与上述
H5文件关联的点云图文件，以及这些点云图对应的图像数据文件的路径的文件。后者的详细信息如下：为了能够让用户快速的找到一个点云图对应的左目相机图像文件，我们也会在
上述PCD文件所在目录生成一个frame_x_image_path.txt，文件中存放该帧的左目图像文件的全路径。
\end_layout

\begin_layout Section
计算KITTI Raw的点云图
\end_layout

\begin_layout Standard
我们选用的KITTI数据集没有包含视差图（网上也没有找到这样的数据集），需要开发者从该数据集的原始数据中推算。
\end_layout

\begin_layout Subsection
立体匹配算法的选择
\end_layout

\begin_layout Subsubsection
算法排行榜
\end_layout

\begin_layout Standard
KITTI官方网站有一个这类算法的排行榜，链接为https://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?b
enchmark=stereo。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
错误测度。对于每帧图像，KITTI数据集提供有部分像素点的真值视差数据。如果一个像素的视差估计和真值的差在3个像素以内，则被认为正确，否则被认为是异常点（out
lier）。异常点的数目除以所有的具有真值数据的像素点的数量，就是被标注为D1-all的错误率。排序的依据就是D1-all。
\end_layout

\begin_layout Subsubsection
选择思路
\end_layout

\begin_layout Standard
选择标准。
\end_layout

\begin_layout Standard
- 错误率不能太高。我们虽然不追求最小的错误率，但是，如果一个立体匹配算法输出太多的异常点，会影响后续算法，最终会影响避障性能。
\end_layout

\begin_layout Standard
- 不要求实时的性能。由于本系统部署阶段计划使用ZED内置的立体匹配算法，该算法能够实时计算。而在实验阶段这个计算速度不重要。
\end_layout

\begin_layout Standard
-
\begin_inset space \space{}
\end_inset

可以使用python后者C++。如同KITTI的那个排行榜所示，这个领域中提供了源代码的系统一般都是使用python做的。当然，选用C++的系统的一个好处是便于
张波理解、应用这些系统。
\end_layout

\begin_layout Standard
-
\begin_inset space \space{}
\end_inset

优先选择KITTI排行榜中的系统，因为这些系统操作的是KITTI数据集，和我们的情形匹配。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
有以下选择。
\end_layout

\begin_layout Standard
1.KITTI官方网站（https://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=ster
eo）列出了很多开源的计算视差图的立体匹配算法。MADNet排在235位（很靠后）。大部分采用Python编写，少部分采用C++。优先选择有代码、关联论文的。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
2.我们要重现的论文@lsd-20中使用的是MADNet。作者认为该算法在计算速度和性能综合考虑中最好。选用这个算法可以忠实的复现目标论文。该算法是使用pytho
n语言实现的。一些进一步的信息如下。@rsd-19中的MADNet（是@lsd-20中引用的）。作者后续的工作为@caf-21中的MADNet++。两个系统的代
码位于https://github.com/CVLAB-Unibo/Real-time-self-adaptive-deep-stereo，2018年发布，202
2年在更新，391星。由于理解MADNet++需要更多时间，如果需要在这二者中选择，我会选用MADNet。
\end_layout

\begin_layout Standard
张波在实验中发现其速度很慢而且结果不正确。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
2.如果ZED中的算法可以被用来处理离线双目图像，利用之。该算法提供C++接口，而且，生产阶段很可能也用这个算法。可能的问题：ZED SDK在计算深度信息时，只能
使用ZED设备本身的物理特征（比如双目间距）。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
PaperWithCodes网站https://paperswithcode.com/task/stereo-matching-1/latest也列出了很多，都是
基于python的。
\end_layout

\begin_layout Subsubsection
候选软件
\end_layout

\begin_layout Paragraph
使用Python开发的
\end_layout

\begin_layout Standard
IGEV-Stereo。https://github.com/gangweiX/IGEV。KITTI上的错误率为1.59%，很好。只针对立体匹配任务设计。华中科技大
学2023年的工作。
\end_layout

\begin_layout Standard
croco-Stereo。KITTI上的错误率为1.59%，很好。是针对3个任务设计的：3D重建，立体匹配，光流估计。其他信息参下。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
coex。官方网站https://github.com/antabangun/coex，使用Python实现。论文为Correlate-and-Excite:
 Real-Time Stereo Matching via Guided Cost Volume Excitation。安装失败。
\end_layout

\begin_layout Standard
https://github.com/iwatake2222/play_with_tensorrt/tree/master/pj_tensorrt_depth_s
tereo_coex有一个C++实现，但是项目质量一般。
\end_layout

\begin_layout Standard
GWCNet。https://github.com/xy-guo/GwcNet。kitti排行榜中有其多个变体。269星。香港中文大学的。运行时出错。
\end_layout

\begin_layout Standard
PSMNet。https://github.com/JiaRenChang/PSMNet。CVPR 2018论文。网站中的内容更详细。1.2k星。无法下载其预训练模
型。相关的一个项目是该算法的实时实现：https://github.com/JiaRenChang/RealtimeStereo。
\end_layout

\begin_layout Standard
PCWNet。Python实现，https://github.com/gallenszl/PCWNet（代码于2022年12月发布，比论文晚好些）。百度的工作。2
022年3月是在KITTI的排名中第一。提供了针对KITTI 2012的预训练模型（400MB）。论文已经下载。
\end_layout

\begin_layout Standard
LEAStereo。Python编写。https://github.com/XuelianCheng/LEAStereo，2020年发布，214星。
\end_layout

\begin_layout Standard
CFNet。https://github.com/gallenszl/CFNet。CVPR2021。
\end_layout

\begin_layout Standard
DSMNet。https://github.com/feihuzhang/DSMNet
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
使用C++开发的
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
PRiMEStereoMatch。https://github.com/PRiME-project/PRiMEStereoMatch。2017年论文，刊物为ACM
 Transactions on Embedded Computing Systems (TECS)。使用了OpenCL。支持从ZED设备获得双目图像并立即处理
。从其介绍看项目规范。KITTI的排行榜中没有该算法。在Middlebury数据集的坏像素比率为
\series bold
6.41%
\series default
。该论文中回顾的一个最好方法的是3.97%。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
OpenCV。依据KITTI排行榜，这个算法（名字为OCV-SGBM）的性能挺靠后的，为298名，D1-all错误率为10.86%，运行时间到还可以，没有使用GP
U时的速度为1.1s。相关的类为StereoBM以及StereoSGBM。前者实现K.
 Konolige的算法，后者实现修改的H.
 Hirschmuller算法。后者的论文为：Heiko Hirschmuller.
 Stereo processing by semiglobal matching and mutual information.
 Pattern Analysis and Machine Intelligence, IEEE Transactions on, 30(2):328–341,
 2008。更多信息参https://docs.opencv.org/4.x/d2/d85/classcv_1_1StereoSGBM.html#details。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
PatchMatch。https://github.com/nebula-beta/PatchMatch。大部分为C++，有一部分是Python。中文社区作者。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
SDR。https://github.com/TingmanYan/SDR。只是研究如何对已经得到的视差图的改进（refinement），并不是一个完整的系统。2
019，IEEE Transactions on Image Processing。作者是上海交大、深圳大学的。低运算量。依赖OpenCV库。KITTI的排行榜
中没有该算法。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
其他无法获得代码的。
\end_layout

\begin_layout Standard
UCFNet。C++实现，无法获得代码。
\end_layout

\begin_layout Standard
PFSMNet。C++实现，无法获得代码。论文：K.
 Zeng, Y.
 Wang, Q.
 Zhu, J.
 Mao and H.
 Zhang: Deep Progressive Fusion Stereo Network.
 IEEE Transactions on Intelligent Transportation Systems 2021。
\end_layout

\begin_layout Subsubsection
IGEV-Stereo
\end_layout

\begin_layout Paragraph
构建运行环境
\end_layout

\begin_layout Standard
准备。需要先安装CUDA Runtime 12.1以及Pytorch，具体步骤参相关文档。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该软件使用conda管理虚拟环境。执行以下命令创建并切换到需要的一个虚拟环境：
\end_layout

\begin_layout Standard
conda create -n IGEV_Stereo python=3.8
\end_layout

\begin_layout Standard
conda activate IGEV_Stereo
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
安装conda软件包。执行以下命令。
\end_layout

\begin_layout Standard
conda install cudatoolkit=11.3 -c pytorch -c nvidia
\end_layout

\begin_layout Standard
这个命令会安装cudatoolkit-11.3.1，其中含有cufft，cublas等库，它并不是CUDA运行时库。这个版本号是它自身的，和CUDA运行时库的版本号
没有关系。
\end_layout

\begin_layout Verbatim
pip install opencv-python
\end_layout

\begin_layout Verbatim
pip install scikit-image
\end_layout

\begin_layout Verbatim
pip install tensorboard
\end_layout

\begin_layout Verbatim
pip install matplotlib 
\end_layout

\begin_layout Verbatim
pip install tqdm
\end_layout

\begin_layout Verbatim
pip install timm==0.5.4
\end_layout

\begin_layout Verbatim
# 虽然官方没有给出，但是在我的机器上还需要执行以下的安装命令。
\end_layout

\begin_layout Verbatim
pip install opt-einsum
\end_layout

\begin_layout Paragraph
概述
\end_layout

\begin_layout Standard
提出的模型适用于双视角以及多视角立体场合，我们只关心前者，对应的子目录是IGEV-Stereo。
\end_layout

\begin_layout Paragraph
使用预训练模型处理数据
\end_layout

\begin_layout Standard
被处理的数据可以是演示用的两对儿图像（位于demo-imgs目录），也可以是KITTI Stereo 2015数据集。由于前者简单易懂，我们只研读前者。本节描述
这个过程。
\end_layout

\begin_layout Standard
下载预训练模型。访问https://github.com/gangweiX/IGEV，沿着其中的链接下载预训练模型，在项目根目录下创建一个名字为pretraine
d_models的目录，将这个预训练模型文件（连同它的上层路径）复制到这个pretrained_models目录。
\end_layout

\begin_layout Standard
对于demo-images下的数据的处理，在项目根目录下执行：
\end_layout

\begin_layout Standard
python demo_imgs.py --restore_ckpt ./pretrained_models/kitti/kitti15.pth
\end_layout

\begin_layout Standard
命令执行中，会下载一个文件，具体的提示信息如下：
\end_layout

\begin_layout Standard
Downloading: "https://github.com/rwightman/pytorch-image-models/releases/download
/v0.1-weights/mobilenetv2_100_ra-b33bc2c4.pth" to /home/zb/.cache/torch/hub/checkpo
ints/mobilenetv2_100_ra-b33bc2c4.pth
\end_layout

\begin_layout Standard
这个文件的大小为13.5MB。直接访问github的速度慢，因而这个下载操作需要花费些时间。
\end_layout

\begin_layout Standard
输出文件位于目录demo-output。
\end_layout

\begin_layout Subsubsection
croco-Stereo
\end_layout

\begin_layout Paragraph
安装
\end_layout

\begin_layout Standard
本节描述在sw机器上的安装过程。
\end_layout

\begin_layout Standard
该软件依赖conda，因此首先需要安装conda。
\end_layout

\begin_layout Subparagraph
安装conda包
\end_layout

\begin_layout Standard
算法包括一个预训练阶段，用户可以自行执行这个与预训练操作，或者从该软件包官网下载已经训练好的预训练模型。如果是前一种方式，需要安装一个名为habitat-sim
的包以及其他一些包。我选择的是后面这种方式，因而并不要安装这些包。以下命令创建一个conda虚拟环境并安装需要的conda包。
\end_layout

\begin_layout Standard
conda create -n croco python=3.7 cmake=3.14.0
\end_layout

\begin_layout Standard
conda activate croco
\end_layout

\begin_layout Standard
conda install pytorch torchvision -c pytorch
\end_layout

\begin_layout Standard
conda install notebook ipykernel matplotlib
\end_layout

\begin_layout Standard
conda install ipywidgets widgetsnbextension
\end_layout

\begin_layout Subparagraph
编译CUDA核函数以使能RoPE
\end_layout

\begin_layout Standard
在sw机器上没有能够完成这个操作。其中涉及到设置一个CUDA_HOME环境变量，应该令其为一个目录，该目录含有bin/nvcc等文件。在sw机器上，对应的命令是
：export CUDA_HOME=/usr/lib/nvidia-cuda-toolkit
\end_layout

\begin_layout Subparagraph
下载预训练模型
\end_layout

\begin_layout Standard
官网提供了针对几种不同任务的预训练模型，包括3D重建，立体匹配以及光流。对于立体匹配任务，使用以下的链接手工下载模型：
\end_layout

\begin_layout Standard
https://download.europe.naverlabs.com/ComputerVision/CroCo/StereoFlow_models/crocos
tereo.pth
\end_layout

\begin_layout Standard
然后创建一个目录stereoflow_models，并存放上述下载的模型。这个模型的文件容量为1.7GB。项目源代码树中的下载脚本stereoflow/downl
oad_model.sh在执行到wget时，无法下载。
\end_layout

\begin_layout Paragraph
概述
\end_layout

\begin_layout Standard
https://github.com/naver/croco。这个软件包是针对3个任务设计的：3D重建，立体匹配，光流估计。
\end_layout

\begin_layout Standard
KITTI上的错误率为1.59%。使用预训练模型。
\end_layout

\begin_layout Subsubsection
MADNet++
\end_layout

\begin_layout Standard
@caf-21，其思路类似于抗噪音语音识别中的PMC：由于训练集中的数据不可能覆盖所有测试集中的情形，模型总是不能很好地匹配测试情形。我们可以调整模型，以使其更
加适应测试情形。该论文实现的是一个“持续学习”算法。该系统将神经网络分为若干个模块，在持续学习阶段，能够选择部分模块进行独立的神经网络权值调整操作。这个思想是我
使用神经网络时曾考虑过的一个重要问题。
\end_layout

\begin_layout Standard
其核心思想是：This suggests that traditional algorithms may be exploited to supervise
 online deep stereo networks if matching errors, i.e.
 out- liers, are properly detected and ﬁltered out。
\end_layout

\begin_layout Standard
问题：
\end_layout

\begin_layout Enumerate
既然传统算法具有domain不变形，为何不直接用它们？
\end_layout

\begin_layout Enumerate
这个做法需要执行传统算法一次，会不会增加计算量？
\end_layout

\begin_layout Standard
我并没有深究这个算法，原因是该算法比MATDNet中的复杂，理解以及重现起来需要跟多的时间。而我的目的只是算出KITTI的视差图数据，并不是研究立体算法本身。
\end_layout

\begin_layout Subsubsection
MADNet
\end_layout

\begin_layout Paragraph
MADNet概述
\end_layout

\begin_layout Standard
@rsd-19，代码位于https://github.com/CVLAB-Unibo/Real-time-self-adaptive-deep-stereo，
\bar under
M
\bar default
odularly 
\bar under
AD
\bar default
aptive 
\bar under
Net
\bar default
work。其思路和后来的MADNet++类似：类似于抗噪音语音识别中的PMC，由于训练集中的数据不可能覆盖所有测试集中的情形，模型总是不能很好地匹配测试情形。我
们可以调整模型，以使其更加适应测试情形。该论文实现的是一个“持续学习”算法。该系统将神经网络分为若干个模块，在持续学习阶段，能够选择部分模块进行独立的神经网络权
值调整操作，这个做法被称为Modular ADaptation (MAD)。这个思想是我使用神经网络时曾考虑过的一个重要问题。
\end_layout

\begin_layout Standard
在持续学习部分，采用的是一个无监督的损失函数。在整个网络被适配（adaptation）的情形下，能够实现15 FPS的速度。为了进一步提高适配速度，神经网络被分
为若干模块，各个模块可以独立的被训练。在损失一点儿系统性能的条件下，只对部分模块进行适配，可以实现25 FPS的速度。系统适配完一个新环境的延时为：完全适配需要
10秒，使用MAD算法进行的部分适配需要6秒。
\end_layout

\begin_layout Standard
创意来源。该文章的创意来自于光流（optical flow）中的研究。
\end_layout

\begin_layout Standard
训练阶段。一个流行的方法是使用合成数据，因而可以有大量的训练数据。之后，使用有标注的数据集微调模型（fine-tuning）。
\end_layout

\begin_layout Paragraph
MADNet的安装
\end_layout

\begin_layout Standard
依赖。我们使用conda管理python的虚拟环境，使用conda的源以及pip的源安装了该程序依赖的以下包：
\end_layout

\begin_layout Standard
python 3.6 # 是以下的tensorflow-gpu要求的一个版本
\end_layout

\begin_layout Standard
tensorflow-gpu==1.12 #注意不是tensorflow
\end_layout

\begin_layout Standard
numpy==1.16 #安装tensorflow的时候安装的是1.19，就尝试使用这个高版本的。
\end_layout

\begin_layout Standard
matplotlib # 没有指定版本，只使用该名字，安装的是版本3.3.4.
\end_layout

\begin_layout Standard
opencv-python==4.1.1.26 #conda源中没有，从pip源安装：install opencv-python==4.1.1.26
\end_layout

\begin_layout Paragraph
输入列表文件准备
\end_layout

\begin_layout Standard
主程序参数涉及的信息中，只有输入文件列表文件是用户需要创建的，以指向被处理双目相机数据以及基准真值。该文件是文本格式的，每行对应双目相机的一帧数据，格式为：
\end_layout

\begin_layout Standard
path_to_left_rgb,path_to_right_rgb,path_to_groundtruth
\end_layout

\begin_layout Standard
前两项容易理解，最后一项指向一个真值文件，其含义在该工具的文档中并没有说明，我通过阅读该项目源代码来推测之。如果该文件的扩展名为pfm或者PFM，表示它是PFM
格式的图像文件，关于这种格式的介绍参https://linux.die.net/man/5/pfm。该文件也可以是其他格式的图像文件。无论哪种格式，要求该文件是一个
图像文件，而不是激光雷达生成的点云图数据。本工作令这个参数指向kitti的深度真值数据集中的文件。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
生成输入列表文件。我们依据上述深度真值数据集的train以及val两个部分的深度真值，参考kitti数据集中的双目相机的图像数据，生成输入列表文件。这个列表文件
实际上是所涉及的图像文件的一个索引。我们使用C++程序/sw/cv/datasetConstruction/kitti/generateMadnetInputL
ist来生成。
\end_layout

\begin_layout Standard
这个程序的思路是依据驾次列表文件（kittiDataDirectory.txt）中的内容，逐个处理驾次。对于每个驾次，先在深度真值数据集中检查是否含有该驾次，如果
有，记录它出现在train还是val部分。然后，依据原始数据集中的时间戳文件获得其帧数，最后生成该驾次中各帧在目标列表文件中的对应内容。
\end_layout

\begin_layout Standard
对于深度真值数据集，image_02/03分别和原始数据集中的同名目录对应，因而是和双目彩色相机对应的。由于一个物体距离左右相机的距离不同，所以该数据集在上述两
个目录中存放着相对于左、右相机的距离信息。不过，当物体距离双目相机较远时，到二者的距离近似相等。我使用image_02中的数据。【todo】将来需要审视这个做法
是否合理。
\end_layout

\begin_layout Paragraph
用法
\end_layout

\begin_layout Standard
参考其README.MD中的Online Adaptation Step by step on Video Sequences部分。主程序是Stereo_Onli
ne_Adaptation.py，而不是Stereo_Continual_Adaptation.py，后者是MADNET++的主程序。
\end_layout

\begin_layout Standard
主控脚本。/sw/cv/generateDepthMap/r。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
预训练模型。主程序的参数中有一个是关于预训练模型的，该模型从该包官网给出的google drive下载。
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

解压后，一个目录为pretrainedMadnet/MADNet/kitti，该目录下文件内容为：
\end_layout

\begin_layout Verbatim
weights.ckpt.data-00000-of-00001  weights.ckpt.index  weights.ckpt.meta
\end_layout

\begin_layout Standard
程序的参数应该设置为：
\end_layout

\begin_layout Verbatim
--weights pretrainedMadnet/MADNet/kitti/weights.ckpt 
\end_layout

\begin_layout Standard
执行主控脚本，有以下警告错误：
\end_layout

\begin_layout Standard
WARNING: flag for trainign not setted, using default False
\end_layout

\begin_layout Standard
WARNING: warping flag not setted, setting default True value
\end_layout

\begin_layout Standard
WARNING: context_net flag not setted, setting default True value
\end_layout

\begin_layout Standard
WARNING: radius_d not setted, setting default value 2
\end_layout

\begin_layout Standard
WARNING: stride not setted, setting default value 1
\end_layout

\begin_layout Standard
Step: 0 bad3:0.92 EPE:16.32 SSIM:0.24 f/b time:6.236761 Missing time:0:00:31.183803
\end_layout

\begin_layout Standard
另外，程序的速度非常慢，处理5帧花了好几分钟。
\end_layout

\begin_layout Standard
todo】这个程序哪个地方可以设置双目相机的距离等参数？
\end_layout

\begin_layout Subsubsection
coex
\end_layout

\begin_layout Paragraph
安装
\end_layout

\begin_layout Standard
解压缩。其子目录logs中已经包含了预训练模型，只有32MB。
\end_layout

\begin_layout Standard
依赖。
\end_layout

\begin_layout Standard
OpenCV 4.x。
\end_layout

\begin_layout Standard
CUDA + cuDNN
\end_layout

\begin_layout Standard
TensorRT 8.x。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
安装。该软件使用conda来管理python环境。文档给出的环境配置命令：
\end_layout

\begin_layout Standard
conda env create -f environment.yml
\end_layout

\begin_layout Standard
这个过程中需要安装一大堆软件，其中，pytorch 1.11 1GB。cudatoolkit-11.3.1，有800多MB，慢。而且，安装了25%时失败。
\end_layout

\begin_layout Standard
下载环境。conda remove --name coex --all
\end_layout

\begin_layout Subsubsection
coex/TensorRT
\end_layout

\begin_layout Standard
https://github.com/iwatake2222/play_with_tensorrt/tree/master/pj_tensorrt_depth_s
tereo_coex
\end_layout

\begin_layout Paragraph
安装
\end_layout

\begin_layout Standard
文献。https://github.com/iwatake2222/play_with_tensorrt
\end_layout

\begin_layout Standard
下载。从https://github.com/iwatake2222/play_with_tensorrt下载软件包，其中含有多个使用TensorRT的项目。我关
心的是pj_tensorrt_depth_stereo_coex。
\end_layout

\begin_layout Subsubsection
GWCNet
\end_layout

\begin_layout Paragraph
安装
\end_layout

\begin_layout Standard
环境。作者并没有将所依赖的python包完全列出，以下是需要我手工配置/安装的：
\end_layout

\begin_layout Standard
-python 3.6。这个可以在创建conda环境时指定，以下都是需要手工安装的包。
\end_layout

\begin_layout Standard
-pytorch 0.4.1。我曾尝试安装该软件的最新版1.12.1，但是它要求python具有更高的版本因而没有成功安装。
\end_layout

\begin_layout Standard
-torchvision 0.2.1。
\end_layout

\begin_layout Standard
-tensorboardX 2.2。
\end_layout

\begin_layout Standard
-scikit-image 0.13.0。在该软件代码中模块的名字为skimage，不过，在conda源中包的名字如前。
\end_layout

\begin_layout Paragraph
论文中的实验
\end_layout

\begin_layout Standard
数据集。一个数据集是Scene Flow，双目相机的数据是合成的，因而具有正确的真值。其他两个数据集是KITTI 2012以及KITTI 2015，它们只有稀疏
的激光雷达深度数据。不同的数据集对应的评测指标也不同。对于KITTI 2015，使用的是视差图中异常点（outliers）的比例，记为D1。所谓异常点，指的是视
差图中的一些像素，这些像素处的视差错误比max(3px, 0.05d*)要大，其中d指的是该像素对应的正确真值。
\end_layout

\begin_layout Standard
设备。使用8张Nvidia TITAN Xp GPU（每个具有3840个核）。
\end_layout

\begin_layout Standard
训练总体过程。先使用Scene Flow数据集训练，再使用KITTI 2012或者KITTI 2015微调模型。
\end_layout

\begin_layout Standard
评测。对KITTI 2015中的（部分）测试数据执行推理。程序在屏幕上输出“loading model ...”的一行后，很长时间没有动作，最后抛出异常“Runtim
eError: cublas runtime error”。
\end_layout

\begin_layout Paragraph
代码分析
\end_layout

\begin_layout Standard
脚本。子目录scripts下是驱动python程序的脚本。其中，sceneflow.sh在Scene Flow数据集训练，kitti15.sh在KITTI
 2015数据集微调模型，kitti15_save.sh对KITTI 2015的测试集执行推理。
\end_layout

\begin_layout Standard
程序。主程序只有两个：1.
 main.py。完成训练、微调任务。 2.save_disp.py。完成推理。
\end_layout

\begin_layout Standard
预训练模型。作者提供了2个预训练数据集，我们采用的是在KITTI 2015微调之后的模型。
\end_layout

\begin_layout Subsubsection
PRiMEStereoMatch
\end_layout

\begin_layout Paragraph
安装
\end_layout

\begin_layout Standard
该应用程序依赖3.x版本的OpenCV库，而Mint 20.04的软件源中的opencv是4.x的，构建过程中有多个错误。解决的方法是卸载4.x的opencv，下载3.4
版本的opencv，构建并安装之。
\end_layout

\begin_layout Paragraph
算法概述
\end_layout

\begin_layout Standard
官网为http://www.prime-project.org/stereo-matching-algorithm-download/，代码位于https://gi
thub.com/PRiME-project/PRiMEStereoMatch。
\end_layout

\begin_layout Standard
2018年论文，作者机构属于英国以及印度。相关的是第一个作者的博士论文，293页。刊物为ACM Transactions on Embedded
 Computing Systems (TECS)。使用了OpenCL。支持从ZED设备获得双目图像并立即处理。
\end_layout

\begin_layout Standard
论文的侧重点在如何动态调整计算设备的运行频率以及运行核的数量，使匹配算法能够在匹配性能以及能耗之间动态调整。这个问题并不是我目前阶段关心的，可以在看论文时忽略相
关内容。
\end_layout

\begin_layout Standard
程序有7000多行C++代码。
\end_layout

\begin_layout Standard
算法并没有使用神经网络，而是使用传统的滤波方法。
\end_layout

\begin_layout Standard
算法也适用于室内双目图像。
\end_layout

\begin_layout Standard
利用CPU多核或者（还是以及？）GPU多核两级并行。软件包也顺带实现了Semi-Global Block Matching (SGBM)算法。
\end_layout

\begin_layout Paragraph
算法细节
\end_layout

\begin_layout Standard
一些术语。
\end_layout

\begin_layout Standard
Disparity estimation (DE) 。
\end_layout

\begin_layout Standard
Guided Image Filter (GIF) 。
\end_layout

\begin_layout Standard
Dynamic Concurrency Throttling (DCT) 。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
动态能耗管理。对于采用电池的嵌入式设备，应该尽量降低其功耗以延长电池寿命。计算量大的任务一般耗电多，为了降低其耗电，一个方法是动态调整计算量。调整计算量的一个方
法是选择参与运算的GPU核的数量。例如，在机器人避障任务中，当机器人检测到路面平坦时，可以使用较少的核，即使此时算法性能稍低。只有当距离障碍物较近或者障碍物以一
定速度接近时，才需要使用更多的核，以得到最好的性能。不过，对于本项目中的无人车，主要功耗应该来自车的驱动（大约600W），而不是计算部分（大约15W）。
\end_layout

\begin_layout Standard
该工作的算法流程如下。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/disparity_estimation/primeStereoMatch_blockDiagram.png

\end_inset


\end_layout

\begin_layout Standard
核心是cost volume的构建、滤波、选择。
\end_layout

\begin_layout Standard
Cost volume constrauction算法来自@rls-11。该论文认为读者已经具有立体匹配算法的一些基础知识。为了理解该论文，我阅读了有这方面内容
的书籍@cva-22。
\end_layout

\begin_layout Standard
==
\end_layout

\begin_layout Standard
核心是chapter 12，但是轻度依赖之前的章节。为了知识完整性，我阅读了之前的相关内容。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
一些其他想法。
\end_layout

\begin_layout Standard
立体匹配这个领域做的人已经很多，不要在这领域做工作。
\end_layout

\begin_layout Paragraph
对程序的理解
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
项目头文件StereoMatch.h中定义了一个宏DISPLAY，使得程序运行时能够显示一些图像信息，这个功能便于理解程序的功能。
\end_layout

\begin_layout Paragraph
对程序的修改
\end_layout

\begin_layout Standard
该程序的文档对程序的使用方法描述的并不是很清晰，需要我理解该程序的源代码方可使用之。为了便于理解，我简化了程序，以下是主要修改。
\end_layout

\begin_layout Paragraph
程序用法
\end_layout

\begin_layout Standard
程序运行环境设置。该程序使用OpenCL，需要配置好目标机器中的OpenCL实现。包括删除无效或者多余的OpenCL实现比如FreeOCL。
\end_layout

\begin_layout Standard
当被处理的是KITTI中的双目图像时，格式如下：
\end_layout

\begin_layout Verbatim
PRiMEStereoMatch image -l <left image filename> -r <right image filename>
  
\end_layout

\begin_layout Verbatim
                       -gt <ground truth filename> 
\end_layout

\begin_layout Verbatim
                       -a  <STEREO_GIF>或者<STEREO_SGBM>
\end_layout

\begin_layout Standard
当使用参数STEREO_SGBM时，长时间没有处理完毕一对儿图像。
\end_layout

\begin_layout Standard
==
\end_layout

\begin_layout Standard
data目录。含有一些测试图像数据。
\end_layout

\begin_layout Standard
==
\end_layout

\begin_layout Standard
处理图像时需要指定双目相机的参数吗？如何指定？
\end_layout

\begin_layout Subsection
KITTI Raw数据集的索引文件
\end_layout

\begin_layout Standard
KITTI Raw数据集具有比较复杂的目录结构。为了便于后续多个程序对KITTI Raw数据集进行处理，我们生成一个H5格式的索引文件。各个数据项具有以下的目录
结构。
\end_layout

\begin_layout Verbatim
sequenceNumber            # Depth数据集中总的序列（驾次）的数目。
\end_layout

\begin_layout Verbatim
seq_n                     # 序列n的数据
\end_layout

\begin_layout Verbatim
    kittiSequenceID       # 类型为string，是该序列在KITTI数据集中的序列标识，一个例子：
\end_layout

\begin_layout Verbatim
                          # 2011_09_26_drive_0001_sync
\end_layout

\begin_layout Verbatim
                          # 依据这个标识，能够找到该序列的其他所有信息，例如对应的场景名。
\end_layout

\begin_layout Verbatim
                          # 由于这个原因，本H5文件不再存放一个序列的其他关联信息。   
\end_layout

\begin_layout Verbatim
    leftImages            # 类型为vector<string>，第k个元素存放第k帧的左目相机的图像的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/dbase/kittiRaw/Road/2011_10_03/2011_10_03_dri
ve_0042_sync/image_02/
\end_layout

\begin_layout Verbatim
                          #   data/0000001164.png
\end_layout

\begin_layout Verbatim
    rightImages           # 类型为vector<string>，第k个元素存放第k帧的左目相机的图像的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/dbase/kittiRaw/Road/2011_10_03/2011_10_03_dri
ve_0042_sync/image_02/
\end_layout

\begin_layout Verbatim
                          #   data/0000001164.png
\end_layout

\begin_layout Verbatim
                          # 上述两个数据项的元素个数就是序列的帧数，应该是相等的。
\end_layout

\begin_layout Verbatim
    disparityImages       # 类型为vector<string>，第k个元素存放第k个帧对的视差数据文件的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/exp/kittiRawDisparity/seq_100/frame_34.png
\end_layout

\begin_layout Verbatim
    pointClouds           # 类型为vector<string>，第k个元素存放第k个帧对的点云图文件的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/exp/kittiRawPointCloud/seq_100/frame_34.ply
\end_layout

\begin_layout Verbatim
    cameraCalibration     # 该目录存放录制该序列的那天的相机校准数据。从深度图计算点云图的操作中将用到这个数据
\end_layout

\begin_layout Verbatim
                          # 对于同一天录制的所有序列，这个数据是相同的。因此，这个数据会被重复存放多次。
\end_layout

\begin_layout Verbatim
                          # 由于其容量很小，并不会造成大的问题。
\end_layout

\begin_layout Verbatim
        left_P_rect       # 类型为一个eigen::Matrix，形状为3x4，是左目相机的射影矩阵。
\end_layout

\begin_layout Verbatim
                          # 由于深度到点云转换只用到这个矩阵，我们并没有存放其他校准数据。
\end_layout

\begin_layout Standard
其中的数据项是多个程序输出的。例如，leftImages/rightImages是程序generateKittiRawIndex生成的，而disparityIm
ages部分是Python项目IGEV_Stereo生成的。
\end_layout

\begin_layout Standard
左目图像文件的快捷查看。当用户已经位于上述一个sequence的目录下（比如/sw/cv/exp/kittiRawPointCloud/seq_100），可以调
用以下脚本来快捷地查看一帧的左目图像：
\end_layout

\begin_layout Standard
#!/usr/bin/fish
\end_layout

\begin_layout Standard
cat frame_$argv[1]_image_path.txt | read imageFilePath
\end_layout

\begin_layout Standard
xdg-open $imageFilePath &
\end_layout

\begin_layout Subsection
程序generateKittiRawIndex
\end_layout

\begin_layout Standard
该程序生成KITTI Raw的h5索引文件的基本信息，比如leftImages/rightImages等。程序的用法参脚本run头部的注释。
\end_layout

\begin_layout Subsection
使用IGEV_Stereo计算视差图
\end_layout

\begin_layout Standard
编程语言的选择。本项目部署阶段的立体匹配是由ZED SDK来完成的，并不需要我们自行编写。对于IGEV-Stereo，我们只要能让它处理KITTI-Raw数据集
即可。这个包使用Python语言开发，因而最简单的用法是修改其Python源代码以处理KITTI-Raw数据集。
\end_layout

\begin_layout Standard
使用该软件包在KITTI Stereo 2015数据集上训练得到的预训练模型，细节参这个包的介绍部分。这个工作的源代码位于/sw/obstacleAvoidan
ce/calculateKittiRawDisparity。我们仍然使用“在开发机上修改代码，然后上传到sw机器运行”的模式，而不是直接在sw机器上修改源代码。
这样做的一个好处是可以使用git管理项目源代码。
\end_layout

\begin_layout Subsubsection
输出文件的路径组织
\end_layout

\begin_layout Standard
KITTI Raw数据集的那个H5索引文件使用“序号+帧对序号”的简单方式来索引一个帧对，本程序也遵循这种方式。为此，需要本程序能够访问H5格式的索引文件。
\end_layout

\begin_layout Standard
由于我们采用了“序号+帧对序号”的方式来索引一个帧对，输出文件的路径组织如下。在用户指定的一个输出目录中，创建seq_n子目录以存放第n个序列的数据。对一个序列
中的第k帧，会生成以下两个输出文件：
\end_layout

\begin_layout Standard
1.视差图。frame_k_effect.png，格式为PNG，生成过程是：使用一个名字为jet的颜色映射方案，将每个视差值映射为一个彩色值。映射后的颜色值只是在视
觉效果方面表示了视差，但是它本身并不表示精确的视差。这个文件主要是供查看用的。
\end_layout

\begin_layout Standard
2.视差数据文件。frame_k.png，格式为PNG，生成过程如下。将IGEV_Stereo算法的输出转换为一个形状为（height, width）的numpy数
组，每个数组元素是一个以像素为单位的浮点数，表示该位置的视差。将每个元素乘以256然后转换为无符号16位整数，最后将其存放到一个PNG文件中。如果使用图像查看软
件来查看这样的PNG文件，显示出来的是一个灰度图像，其亮度表示视差大小。不过，前文的彩色图像能够更清晰地显示视差效果，而本项中的这类文件是被用来存放精确地视差信
息的（不考虑那个浮点数到整数转换引入的误差）。将来，将每个像素点处的值除以256，就是以像素为单位的视差值。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
该程序也会向那个KITTI Raw的H5索引文件添加其中的disparityImages部分，指向上述视差数据文件。细节参该索引文件的说明。
\end_layout

\begin_layout Subsection
程序disparityToPointCloud
\end_layout

\begin_layout Standard
该程序对Kitti Raw数据集的视差图处理，计算得到点云图。我们使用pcl库，其中的计算就是计算机视觉学习笔记中的几个公式，此处以其中计算深度的那个公式来讨论
各个量的单位问题：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
z_{s}=\frac{b\cdot f}{x_{L}-x_{R}}.
\]

\end_inset


\end_layout

\begin_layout Standard
其中，
\begin_inset Formula $b$
\end_inset

是两个相机之间的间距，但是是米。
\begin_inset Formula $f$
\end_inset

是相机的焦距，依据“从深度图计算点云图”一章的描述，KITTI数据集中给出的量的单位为像素。而视差
\begin_inset Formula $x_{L}-x_{R}$
\end_inset

的单位也是像素，所以计算出来的深度的单位为米，符合我们的预期。
\end_layout

\begin_layout Section
ASL论文的复现
\end_layout

\begin_layout Standard
并没有找到更高质量的、和本项目符合（无人车+双目相机）的开源项目，所选择的是@lsd-20，原因是该论文更新，而且作者所在机构技术实力雄厚。
\end_layout

\begin_layout Standard
下图是该论文算法的总体流程。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset Graphics
	filename figures/obstacleDetection/lsd-20-algorithm-pipeline.png
	lyxscale 90
	width 100text%
	groupId full

\end_inset


\end_layout

\begin_layout Standard
接下来我们按照@lsd-20的Methodology中的节的顺序来描述我们的重现工作。
\end_layout

\begin_layout Standard
A部分。这个部分实现立体匹配的功能。该论文实现了另外一篇论文中的一个基于深度神经网络的方法MADNet计算视差图（disparity map）
\begin_inset space \space{}
\end_inset

并获得深度估计，而本项目在部署阶段会使用ZED 2i来实现这个功能，因而我们并不需要重现这个方面的工作。在实验阶段，对于KITTI数据集，如下文所述，我们将使用
另外一个易用、性能更好的算法来执行立体匹配。
\end_layout

\begin_layout Subsection
B部分/滤波以及下采样
\end_layout

\begin_layout Standard
论文这部分对点云图进行滤波以及下采样。对于实验中我们使用另外的立体匹配算法处理KITTI数据集得到的点云图，其性质和论文@lsd-20中所要处理的点云图的不同，
一个例子如下图。该图左侧显示了KITTI数据集中的一幅左目图像，右侧显示对应的点云图。我们因而需要做不一样的处理。安装先后顺序，各个操作如下。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/kittiRawLeftCameraImageSample.png

\end_inset


\begin_inset Graphics
	filename figures/kittiRawPointCloudSample.png

\end_inset


\end_layout

\begin_layout Subsubsection
最大可靠深度
\end_layout

\begin_layout Standard
依据双目相机测量深度的原理，当深度较大（比如超过50米）时，深度方面的分辨率会变差，计算所得深度的步进量高达3米。由于这个原因，ZED相机的手册中指出其最大可靠
深度大约为20米。不过，对于本项目，我们的目的并不是精确测量，而是检测障碍物，所以允许较大的误差。依据汽车驾驶经验，将这个值设置为50米。这个值对于低速运行的无
人车应该足够了：如果检测出来50米远的地方有一个物体，即使它以较快速度运行，无人车也能及时反应。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
相机坐标系到车体坐标系的转换
\end_layout

\begin_layout Standard
点云图中的数据都是相对于相机坐标系的，这个坐标系中，坐标原点是相机成像中心，x轴水平向右，y轴垂直向下，z轴指向车辆正前方。在无人车应用中，我们更偏向于使用车体
坐标系，这个坐标系中，坐标原点是相机成像中心在地面的垂直投影点，x轴水平向右，y轴垂直向上，z轴指向车辆正前方。为了完成这个转换，需要执行以下操作。
\end_layout

\begin_layout Standard
翻转y轴方向。立体匹配算法计算点云图时，依据图像处理的惯例，y轴射向成像平面的垂直下方。对于配备了双目相机的无人车，这是垂直向下。这个方向和无人车研究中的惯例不
同：当我们谈论高度时，一般是以地平面作为参考的相对海拔高度；y轴的方向是垂直向上的。为了便于之后算法的处理，我们在这个滤波阶段翻转y轴方向。
\end_layout

\begin_layout Standard
关联的x轴翻转。执行上述操作时还需要同时翻转x轴的方向，以使得所得点云图和左目相机成像中物体的位置匹配。如果不执行这个操作，这些物体的位置在两种图像中的x轴是相
反的。
\end_layout

\begin_layout Standard
y轴偏移。依据@vmr-13, Fig.
 3，相机的安装高度为1.65m，因而，需要将上述所得的y坐标值加上这个值。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
裁剪地平面以及天花板
\end_layout

\begin_layout Standard
设无人车行走的地面是水平、平坦的，设置一个阀值（比如0.1米），将高度低于这个阀值的点删除，可以裁剪掉地平面。当然，这个做法有明显的局限性：当行驶前方开始上坡时，
这个操作无法裁剪掉上坡路面。当行驶前方开始下坡时，这个操作会裁剪掉下坡路面以及其上的障碍物。而且，当路面上有不适合行驶的坑洼时，这个操作会漏检掉这些障碍物。
\end_layout

\begin_layout Standard
裁剪天花板。设无人车行走的地面是水平的，设置一个阀值（比如3米），将高度高于这个阀值的点删除，被称为裁剪天花板。这个操作的动机是：无人车一般比较矮，高于上述阀值
的空域无论是否有障碍物，都不会影响无人车的通行。当然，这个做法有一个局限性：当行驶前方开始上坡时，这个操作将裁剪掉路面。当行驶前方开始下坡时，这个操作无法裁剪掉
路面上方的那个虚拟的天花板。
\end_layout

\begin_layout Standard
下图显示上述两个裁剪操作的效果。左图是裁剪之前的，右图是裁剪之后的。可以看出，需要处理的障碍物的点的数量大幅减少。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/withoutGroundAndCeilingCropping.png

\end_inset


\begin_inset Graphics
	filename figures/withGroundAndCeilingCropping.png

\end_inset


\end_layout

\begin_layout Standard
可能的改进。识别路面，之后相对于路面执行上述裁剪。另外，处理坑洼。
\end_layout

\begin_layout Subsubsection
下采样
\end_layout

\begin_layout Standard
使用pcl库中的VoxelGrid滤波器对点云实施下采样，得到的点云如下图。可以看出，原来点云的信息基本被保留。但是，处理之后的点云中点的数量从原来的166,6
65个缩减到29,907，5.5倍的缩减。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/pointCloudDownSamplingEffect.png

\end_inset


\end_layout

\begin_layout Subsubsection
移除异常点
\end_layout

\begin_layout Standard
一些点云图本身会含有一些异常点（outlier），而上述下采样操作会产生一些新的异常点。我们使用pcl库中的RadiusOutlierRemoval<Point
T>来滤除这些异常点。
\end_layout

\begin_layout Subsubsection
实现
\end_layout

\begin_layout Standard
C++程序位于/sw/obstacleAvoidance/filterKittiRaw。该程序对KITTI Raw的点云图进行处理，得到一组新的点云图，其索引以
及点云图数据存放在/sw/cv/exp/kittiRawFiltered。
\end_layout

\begin_layout Subsubsection
输出的索引文件
\end_layout

\begin_layout Standard
输出的H5格式的索引文件的目录结构如下。
\end_layout

\begin_layout Verbatim
sequenceNumber            # Depth数据集中总的序列（驾次）的数目。
\end_layout

\begin_layout Verbatim
seq_n                     # 序列n的数据
\end_layout

\begin_layout Verbatim
    kittiSequenceID       # 类型为string，是该序列在KITTI数据集中的序列标识，一个例子：
\end_layout

\begin_layout Verbatim
                          # 2011_09_26_drive_0001_sync
\end_layout

\begin_layout Verbatim
                          # 依据这个标识，能够找到该序列的其他所有信息，例如对应的场景名。
\end_layout

\begin_layout Verbatim
                          # 由于这个原因，本H5文件不再存放一个序列的其他关联信息。   
\end_layout

\begin_layout Verbatim
    leftImages            # 类型为vector<string>，第k个元素存放第k帧的左目相机的图像的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/dbase/kittiRaw/Road/2011_10_03/2011_10_03_dri
ve_0042_sync/image_02/
\end_layout

\begin_layout Verbatim
                          #   data/0000001164.png
\end_layout

\begin_layout Verbatim
    pointClouds           # 类型为vector<string>，第k个元素存放第k个帧的点云图文件的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/exp/kittiRawPointCloud/seq_100/frame_34.ply
\end_layout

\begin_layout Verbatim
    filteredPointClouds   # 类型为vector<string>，第k个元素存放第k个帧的滤波后的点云图文件的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/exp/kittiRawFiltered/seq_100/frame_34.ply
\end_layout

\begin_layout Subsection
C部分/Clustering and 3D Tracking
\end_layout

\begin_layout Standard
该论文使用DBSCAN算法完成聚类操作，宣称该算法比Euclidean聚类的效果要好。另外，该论文利用人检测器输出的信息来改良聚类算法。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
3D Tracking。思路直观：计算每个类的质心，基于最近邻的思路关联不同帧中的簇（clusters），该算法简单。
\end_layout

\begin_layout Subsubsection
DBSCAN聚类
\end_layout

\begin_layout Paragraph
文献
\end_layout

\begin_layout Standard
https://en.wikipedia.org/wiki/DBSCAN，关于该算法的总体介绍。
\end_layout

\begin_layout Standard
@adafd-96，提出DBSCAN算法，很老的一篇文章，但是被引用了很多次。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
算法概述
\end_layout

\begin_layout Standard
由于这个算法并非一个“全自动”算法（需要用户确定算法中的参数Eps以及MinPts），因而需要用户理解该算法，也就是用户应该花些时间阅读@adafd-96，至少
要理解算法的主要思想。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
任务。为了便于描述，我们在二维空间来介绍该算法。假设不同物体的像素点是不接触、重合的。设一幅图像中有K个物体，我们的任务是输出K个簇，第k个簇只含有第k个物体的
像素点。对算法的要求：
\end_layout

\begin_layout Standard
1.
 对问题领域相关知识要求最小。
\end_layout

\begin_layout Standard
2.
 能够检测任何形状的物体。
\end_layout

\begin_layout Standard
3.
 算法性能好。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
算法思路。如下图所示，DBSCAN(Density Based Spatial Clustering of Applications with
 Noise）算法依据点的稠密度来聚类。它依据的一个基本观察是：一个簇（记其半径为Eps）的内核点（core point）的领域中每个点是稠密点（所谓稠密点指的
是其领域至少存在MinPts个点）。而簇的每个边界点（border point）的周围至少有一个稠密点（也就是可以从一个稠密点出发可以抵达该边界点）。而噪音点则
不满足上述条件。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/clustering-problem-illustration.png
	width 50text%
	groupId half

\end_inset


\end_layout

\begin_layout Standard
形象地说，可以通过一个扩展过程来构成一个簇：从一个稠密点出发，给定一个点，如果其附近都是稠密点，或者至少有一个稠密点，则该点将被扩展为该簇。这个过程中，一个簇的
边界点由于收到它所属簇的其他稠密点的
\series bold
支持
\series default
，可以被扩展到一个簇中，而噪音点则不行。总之，该算法是依据
\series bold
点密度
\series default
来执行聚类的。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
算法的总体流程。@adafd-96给出的该算法的总体流程如下。
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

依据输入数据中最稀薄的簇，确定算法的参数：领域的半径Eps以及MinPts。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

依次遍历输入数据的每个点，如果一个点尚未被归入一个簇，从它出发执行扩展，以得到它所属的整个簇。
\end_layout

\begin_layout Standard
3.
\begin_inset space \space{}
\end_inset

由于Eps以及MinPts是依据最稀薄簇推算出来的，上述步骤可能会将两个距离较近的簇归入一个簇，因为本步骤还需要检查每个生成的簇，如果它可能是多个簇的合集，则执
行一个分割操作，这可以通过将这个合集作为输入，再递归执行dbscan算法来完成。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
讨论。这个问题是计算机视觉中的一个基本问题：对场景进行分割。该论文使用确定、简单的逻辑规则来完成这个操作，和基于神经网络的不同。
\end_layout

\begin_layout Paragraph
候选的算法实现
\end_layout

\begin_layout Standard
pcl库虽然有一个segmentation模块，但是其中并没有DBSCAN算法。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
以下是活跃的项目。
\end_layout

\begin_layout Standard
mlpack。https://github.com/mlpack/mlpack。活跃，有4.6k星，是一个机器学习库，其中含有dbscan。官网https://ww
w.mlpack.org。其dbscan部分没有估计Eps以及MinPts的代码，但是该库本身具有knn相关代码。
\end_layout

\begin_layout Standard
YgorClustering。https://gitlab.com/hdeanclark/YgorClustering，官网是https://www.halclar
k.ca/YgorClustering.html。忠于原论文。基于Boost.Geometry。提供了参数Eps以及MinPts估计的相关代码。代码精练，质量看起来高
。问题：由于该库以及它所依赖的Boost.Geometry都是纯头文件的，导致编译速度非常慢。
\end_layout

\begin_layout Standard
pyclustering。https://github.com/annoviko/pyclustering。是一个聚类的工具库，提供Python以及C++两种语言
的接口。功能多，相对于我们的需求，该项目太复杂。通过浏览其源代码，对于dbscan算法，该库不具有自动计算Eps以及MinPts的功能。
\end_layout

\begin_layout Standard
oneDAL。https://github.com/oneapi-src/oneDAL/tree/master。是一个机器学习的库，用户可以使用SYCL进行硬件加
速。提供了众多数据分析的功能。用户可以使用普通的x86 CPU或者Intel的一些GPU，不支持Nvidia或者AMD的GPU。浏览其代码，觉得比较啰嗦，可能是
由于需要支持多种硬件导致的。
\end_layout

\begin_layout Standard
DBScan-PCL-Optimized。https://github.com/dtcMLOps/DBScan-PCL-Optimized/tree/master
。该项目使用octree。该项目使用pcl库。网上有人指出octree稍稍慢于kdtree。在我试图将其纳入到我们的程序的时候觉得其代码质量一般。其代码中有估计
Eps的相关代码。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
https://github.com/Eleobert/dbscan。宣称快。使用kdtree。该项目不依赖pcl，使用自己定义的类型来表示被聚类的点。不具有估计
全局Eps以及MinPts的功能。
\end_layout

\begin_layout Standard
https://github.com/weilun-chiu/dbscan，侧重于如何使用CPU的多线程以及AVX指令加速聚类。所使用的硬件加速技术和Jetson
机器的不匹配，所以我不关注之。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
以下是长期没有更新的项目。
\end_layout

\begin_layout Standard
DBScan_Octrees。https://github.com/Hagen23/DBScan_Octrees，6年没有更新。DBSCAN算法的八叉树（octr
ee）实现。
\end_layout

\begin_layout Standard
https://github.com/buresu/DBSCAN/tree/master，9年没有更新。
\end_layout

\begin_layout Paragraph
人工确定算法参数Eps以及MinPts
\end_layout

\begin_layout Standard
由于被处理的输入数据的分布相差较大，无法通过一个算法来全自动的确定算法参数Eps以及MinPts。原论文给出了一个经验算法。这个算法的主要思路是：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

先确定MinPts再确定Eps。而MinPts可以仅仅依据经验来确定。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

MinPts确定后，可以依据最稀薄的那个簇来确定Eps。具体地，将MinPts简写为k。对于这个簇中的每个核心点p，计算它的至少含有k个点的领域，得到该领域半径
。考虑到p点附近各个点到p点的距离一般不会相等，上述计算可以被近似为：给定一个点p，计算其k-近邻点q，二者距离d就是上述领域半径。我们将这样的距离称为k-di
st。对于这个簇的所有内核点，计算出来的最大的k-dist就可以被用做Eps。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
算法描述。由于我们起初并不知道哪些点组成了那个最稀薄的簇，所以并不能直接执行上述步骤2的操作。解决方法是，对输入数据集中的所有点计算上述k-dist，排序，会得
到诸如下图所示的曲线：
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/k-dist.png

\end_inset


\end_layout

\begin_layout Standard
曲线左侧，对于噪音点，由于它们远离所有的簇以及其他噪音点，所以k-dist会较大。而所有簇的k-dist会较小，而且在上述曲线中会缓慢减少。以上因素会导致上述曲
线中存在着一个谷点。这个谷点的k-dist值就是Eps。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
错误设置Eps的影响。如果用户设置的Eps太大，会有更多的点被判定为稠密点，会导致一些噪音点被当做正常点。反之，如果用户设置的Eps太小，会有较少的点被判定为稠
密点，会导致本来属于一些簇的点被误判为噪音。
\end_layout

\begin_layout Paragraph
本项目确定Eps参数的思路
\end_layout

\begin_layout Standard
对于本项目，可以通过观察点云图数据，确定一个适用于所有帧的MinPts。然而，由于各个帧的点在空间中的分布并不同，理论上讲，应该为每帧确定一个最优的Eps。但是
，本项目中帧的数量巨大，并不能这样做。ASL论文只提到使用了DBSCAN算法，并没有介绍如何确定算法的参数Eps以及MinPts。有以下处理思路：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

通过观察本项目中的部分帧的k-dist曲线，人工选择一个全局的Eps。这种思路是这个全局的Eps在一些视频帧中会显得太大或者太小。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

依据http://www.sefidian.com/2022/12/18/how-to-determine-epsilon-and-minpts-parameter
s-of-dbscan-clustering/，使用一个算法来模拟人工确定Eps的过程，为每一帧确定一个Eps。这个思路的问题是上述网页中给出的论文@dooe-
16质量差，而且，并没有自动化上述过程，仍然需要人工干预。
\end_layout

\begin_layout Standard
3.
\begin_inset space \space{}
\end_inset

上述网页还指出，可以对dbscan算法本身进行扩展，使得算法不再需要这样的参数。这样的一个算法为OPTICS，相关论文参@aeocf-03。这种思路更好，但是需
要我们再学习OPTICS算法。
\end_layout

\begin_layout Standard
为了能够快速复现ASL论文，我们采用上述思路1。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
k-dist数据的呈现/程序viewKdist
\end_layout

\begin_layout Standard
本项目中每帧对应着一个k-dist曲线。由于帧的数量巨大，我们逐帧查看的效率太低，我们曾尝试将所有帧的k-dist曲线绘制在一张图上，但是后来发现这个操作很耗时
：处理481帧，大约耗时60秒数量级。而帧的总数为4万帧，这个操作估计需要花费1个小时。由于上述操作中执行了hold操作，加入绘制引擎记录所有被绘制数据，也许无
法记录这么多数据。其他的一些具体信息如下：一些相关的做法如下：由于这个帧中的被分析的点的数量不同，应该将它们的长度规整为相同的数值。做法是将每帧的k-dist曲
线的x轴上数据的变换范围映射为0~1。
\end_layout

\begin_layout Standard
为了解决这个问题，我们采用热图来表示所有帧的k-dist数据：x轴是规整后的点的索引，范围为0~1。y轴是距离，范围为0米~12米。此处的12是我显示seq_0
的k-dist数据时matplot使用的。对上述范围进行等距离划分，最终会得到一个二维网格。对一个帧对应的k-dist数据，给定一个数据点，将其对应的网格点的计
数器加一。处理完所有帧之后，只需显示一次这个热图即可。
\end_layout

\begin_layout Standard
实现。使用C++实现，程序位于obstacleAvoidance/viewKdist。为了加快处理，我们使用了OpenMP。我们使用C++绘制库matplot+
+绘制热图，结果如下。该图x/y轴分别是上述矩阵的列号/行号。注意图中k-dist曲线上的点的y坐标越小，对应的k-dist越大。为了避免歧义，本节接下来的部分
只使用k-dist。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/accumulatedKdist.png

\end_inset


\end_layout

\begin_layout Standard
可以看出，对于KITTI Raw数据集中的所有帧，它们的k-dist曲线的形状大致相同，拐点出现的位置大致相同。我觉得这可能归功于立体匹配算法：该算法的输出本身
就只含有非常少的噪音。在确定Eps值时，除了参考上图，还需要考虑的以下因素：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

Eps在本项目中的物理意义：基本上，它表示实际环境中，物体对应的点云图中，在最稀疏情况下点的物理距离。由于一些物体表面的纹理并不明显，对应的点云图会比较稀疏，可
能会导致这个距离比较大。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

对于避障任务，得到一个虚假障碍物的损失，要小于漏检障碍物的损失。因此，可以将Eps设置的比较大，这样，即使有一些噪音点被纳入簇并最终判定为障碍物，最大也只是令无
人车绕道行驶或者停车。
\end_layout

\begin_layout Standard
3.
\begin_inset space \space{}
\end_inset

查看下文所述的dbscan的聚类结果，调整该参数的值，使得聚类结果符合一般的习惯。例如，应该令道路中的电线杆对应的簇看起来只含有很少的噪音点。
\end_layout

\begin_layout Subsubsection
使用dbscan聚类/程序clusterByDBSCAN
\end_layout

\begin_layout Standard
C++程序位于/sw/obstacleAvoidance/clusterByDBSCAN。该程序对滤波后的点云图聚类。输出两种类型的数据：
\end_layout

\begin_layout Standard
1.簇信息。描述每个点属于哪个簇（或者噪音）。这个信息将被之后的3D Tracking等操作使用。
\end_layout

\begin_layout Standard
2.簇的渲染。为了能够人工查看算法的执行结果，我们仍然希望使用点云图的方式显示算法执行结果。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
上述类型1的信息被存放在一个H5文件中，而类型2的信息被存放为单独的点云图文件，便于查看。输出目录为/sw/cv/exp/clusters。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
输出的H5文件的格式。
\end_layout

\begin_layout Verbatim
sequenceNumber            # Depth数据集中总的序列（驾次）的数目。
\end_layout

\begin_layout Verbatim
seq_n                     # 序列n的数据
\end_layout

\begin_layout Verbatim
    frameNumber           # 存放当前序列的帧数
\end_layout

\begin_layout Standard
一个帧的数据被输出到物理目录seq_n/frame_k下，其中n是它所属序列的编号，k是帧的编号。这个物理目录下的内容为：
\end_layout

\begin_layout Verbatim
    assignments.csv       # 对应的程序中对象类型为arma::Row<size_t>。
\end_layout

\begin_layout Verbatim
                          # 第i个元素是该帧点云图中第i个点所属簇的ID。
\end_layout

\begin_layout Verbatim
                          # 如果此值是SIZE_MAX，该点被判断为噪音。
\end_layout

\begin_layout Verbatim
    centroids.csv         # 对应的程序中对象类型为arma::mat。每个矩阵的形状为3行、C列，C为簇的个数
\end_layout

\begin_layout Verbatim
    pointCloudWithClusterInfo.ply   # 当前帧的点云图，一个簇的点被渲染为同一种颜色，不同簇具有不同的颜色。
\end_layout

\begin_layout Standard
该程序聚类的结果被表示为armadillo库中的对象。由于这些对象本身就提供了I/O函数，我们没有试图将它们集中保存到上述H5文件中，这样可以简化代码。对这些对
象执行I/O操作时，我们选择了csv格式，因为这种格式便于被直接阅读以及审查。
\end_layout

\begin_layout Standard
对于每个sequence，我们不再保存数据项kittiSequenceID，leftImages，pointClouds以及filteredPointCloud
s，原因是我们可以依据sequence以及frame的编号在此前生成的索引h5文件中找到这些信息。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Paragraph
关于渲染的一些细节
\end_layout

\begin_layout Standard
我们的目标是令一个簇中的所有点具有相同颜色，不同簇（尤其是空间中相邻的簇）具有视觉上能够被轻易分辨出来的不同颜色。由于被处理的点云中点的类型为pcl::Poin
tXYZI，我们应该使用其中的Intensity分量来达到这个目的。浏览pcl库中从像素的RGB值映射到Intensity（亮度）部分代码，推断这个亮度部分的取
值范围为0~255之间的整数。而点云图显示软件CloudCompare将亮度映射为彩色值然后以彩色形式呈现这个信息。将簇ID映射为亮度值的基本思路是将其对256
取余，这个操作还需要考虑以下问题：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

DBSCAN算法一般是顺序处理输入点的。如果空间中相邻的点在输入数据的排序也比较接近，会使得空间上相近的簇也具有相近的簇ID。如果直接执行上述取余，所得的亮度值
也相近，这会使得相邻的簇具有相同的着色，不利于查看。为了解决这个问题，我们构建一个0~255之间整数的扰乱映射表，也就是将其中任何一个值映射为这个范围内的一个值
，而且，这个映射是双向一一映射。然后，按照这个映射表对上述取余的值进行扰乱，令所得的值为亮度值。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

噪音点的簇ID。对于这个特殊的类别，我们令其亮度值为0。显示时，这是一个看起来最弱的颜色。这符合此后算法的处理：此后我们只是简单的忽略噪音点。
\end_layout

\begin_layout Paragraph
聚类结果
\end_layout

\begin_layout Standard
下图是对seq_0/frame_0的处理结果。上图是左目相机图像，下图是聚类结果。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/dbscanResult_originalImage.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/dbscanResult.png

\end_inset


\end_layout

\begin_layout Standard
可以看出，dbscan的确能够很好地将三维空间中簇求取出来。
\end_layout

\begin_layout Subsection
D部分/Classiﬁcation as Dynamic or Static
\end_layout

\begin_layout Standard
给定一个簇，判断它的每个点是动态的还是静态的，然后使用一个投票机制来判断整个簇是动态的还是静态的。
\end_layout

\begin_layout Subsection
E部分/2D行人检测 
\end_layout

\begin_layout Standard
任务描述。在左目（或者右目）的二维图像中检测行人。
\end_layout

\begin_layout Standard
作用。这部分检测出的行人信息有以下作用：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

在C部分的聚类中，如果多个人在三维空间中的距离较近，可能被聚类算法归入一个簇，这不利于目标检测。如果本部分能够在二维空间中检测出这些行人，可以将这种簇拆分为多个
簇，使得每个簇对应着一个行人。
\end_layout

\begin_layout Standard
2.
 （其他的作用待述）。
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
程序peopleDetection
\end_layout

\begin_layout Standard
完成这个任务的程序是peopleDetection。该程序的上层流程和clusterByDBSAN类似，所以复用了后者的一些代码。下面的几个小节阐述相关知识以及
具体的实现。
\end_layout

\begin_layout Standard
该程序有两种模式：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

处理一张测试图像。为了调试程序，我们从https://github.com/djmv/MobilNet_SSD_opencv摘取了其中的测试图像。检测其中的行人。
为了使能这种模式，用户在程序的配置文件中使能名字为“processSampleImageOnly”的一个选项，同时通过参数sampleImagePath指定测试
图像文件的路径。处理结果存放在该项目根目录下的文件personsInSampleImage.png中。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

处理KITTI Raw数据集中的左目图像。如果用户没有指定“processSampleImageOnly”选项，程序处理KITTI Raw数据集中的数据。
\end_layout

\begin_layout Standard
这种模式下，所有帧的检测结果会被存放在参数detectedPeopleDir指定的一个输出目录下的文件detectedPerson.h5文件中。如果一个帧的检测结
果中有行人，则会生成一个具有标注的图像文件。
\end_layout

\begin_layout Subsubsection
MobileNet与SSD介绍
\end_layout

\begin_layout Standard
被复现论文使用MobileNet-SSD实现行人检测。关于MobileNet的原创论文是@mecnn-17，关于SSD的原创论文是@sssmd-16。为了理解S
SD，需要理解R-CNN（@rfhfa-14），Fast R-CNN（@fr-15）以及Faster R-CNN（@frtro-16）。相关的讨论参另外的一个笔
记。总体体系结构采用SSD，其中的base network（计算输入图像的特征图像的网络）采用MobileNet，以降低运算量，而其余部分和SSD原创论文中的一
致。
\end_layout

\begin_layout Subsubsection
KITTI中宽图像的处理
\end_layout

\begin_layout Standard
SSD要求输入是300x300（或者500x500）的方形图像。而KITTI中的图像的分辨率是1224 x 370。从纵横比角度看，太宽。如果强行将后者弯曲并下
采样到300x300，将使得图像数据变形的太厉害，将大幅降低目标检测性能。有以下可能的处理思路：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

修改SSD使其能够处理这种宽图像。具体的，针对这种宽图像，修改SSD的网络拓扑结构，在KITTI数据集上训练以得到修改的SSD。这方面的工作参https://g
ithub.com/SeongHoonSeo/SSD-KITTI，以及https://github.com/lucasjinreal/kitti-ssd。这种思路需
要重新设计SSD，还需要重新训练。而具有这种宽图像的图像数据集不多，会使得这种方法并没有大量训练数据。
\end_layout

\begin_layout Standard
2.
\begin_inset space \space{}
\end_inset

沿着图像的水平方向滑动，将输入图像划分为若干个区域。在保持纵横比的前提下，将图像规整为300x300送往SSD预训练模型处理。所有区域的检测结果最终被合并。这种
思路简单易行，被采用。
\end_layout

\begin_layout Subsubsection
选择预训练模型
\end_layout

\begin_layout Standard
下载。https://github.com/djmv/MobilNet_SSD_opencv。这是岳夏薇采用的。所下载的文档中含有预训练模型，以及几个python
演示程序。其介绍参https://docs.openvino.ai/2023.2/omz_models_model_mobilenet_ssd.html以及https:
//ebenezertechs.com/mobilenet-ssd-using-opencv-3-4-1-deep-learning-module-python/
。从后者的介绍可以看出，它所用的模型来自
\begin_inset space \space{}
\end_inset

https://github.com/chuanqi305/MobileNet-SSD，后者作者指出其检测性能为mAP=0.727。但是我试图下载后者放在googl
e云盘上的预训练模型时提示没有访问权限。
\end_layout

\begin_layout Standard
用法。上述开源项目中的Python程序蕴涵有该模型的一些信息（比如所有目标类的名字），同时，这些演示程序是基于OpenCV/Python接口的，因而可以被用来学
习OpenCV/DNN目标检测模块的用法。
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Subsubsection
图像分块
\end_layout

\begin_layout Standard
对于同一个物体，使用不同的摄像设备拍摄出来的照片具有不同的纵横比，但是这个差异是非常小的。这也是人看到这些图像、视频不会感觉到失真的原因。深度网络在训练时，输入
图像一般具有这种标准的纵横比。对于SSD网络，在要求输入图像具有上述标准纵横比的前提下，它还要求输入为300x300。而KITTI中的图像虽然就有上述标准纵横比
，但是其分辨率为1224x370，显然不能满足上述尺寸要求。假如强行将这样的图像规整到300x300，图像中物体的纵横比将被大幅扭曲，必定会影响检测性能。
\end_layout

\begin_layout Standard
解决思路很简单：使用一个370x370的滑动窗口，沿着水平方向滑动，将输入图像分成若干块，各个相邻块之间有一定的重合。将每个块送往SSD网络，检测其中的行人。最
后，将各个块的处理结果拼接，再执行一个NMS，得到最终结果。
\end_layout

\begin_layout Standard
分块的具体做法。设图像的宽度w大于高度h。滑动窗口最开始处于最左端，之后，以h/2步长向右侧滑动，直到恰好滑动到原图像的最右端，或者首次超过最右端。如果超过，则
将其再向左侧滑动，知道其右侧和原图像的最右端对齐。
\end_layout

\begin_layout Subsubsection
NMS层的参数
\end_layout

\begin_layout Standard
对于本项目中采用的那个预训练模型，通过阅读其网络拓扑结构文件（MobileNetSSD_deploy.prototxt），再加上程序运行阶段输出的一些调试信息，知
道该网络已经含有SSD文献中最后的那个NMS层。这个网络拓扑结构文件中指定了这个NMS层的所有算法参数。主要的两个参数如下。
\end_layout

\begin_layout Standard
confidence_threshold。置信度阀值，默认取值是0.25。这是一个较低的值，意味着即使SSD网络以这么低的置信度检测到一个目标，它也可能出现在最终
的检测结果中。
\end_layout

\begin_layout Standard
nms_threshold。NMS算法中的那个IoU参数，默认取值是0.45。这是一个较低的阀值，意味着一个边框和附件的那个置信度最高的边框的IoU达到这个低的阀
值就会被滤除。
\end_layout

\begin_layout Standard
NMS层标量参数的修改方法。通过阅读OpenCV的头文件我们知道，一旦OpenCV构建完毕一个网络对象，任何层中的这种标量参数的值是无法修改的。因为，我们只能通
过直接修改这个网络拓扑结构文件的内容，来修改这些标量参数。不过，我们并没有修改它们的取值。
\end_layout

\begin_layout Subsubsection
影响检测结果的两个程序参数
\end_layout

\begin_layout Standard
对检测性能影响较大的是以下两组参数：
\end_layout

\begin_layout Standard
1.
\begin_inset space \space{}
\end_inset

前一节的对每个图像块处理的NMS层中的置信度以及NMS算法参数。不过，我们的程序保持这两个参数在原模型中的默认取值，并没有修改它们。
\end_layout

\begin_layout Standard
2.
 程序的以下参数：
\end_layout

\begin_layout Standard
confidenceThresholdForPerson。对SSD模型输出的最优的最多100个候选边框，只有当其对应置信度超过这个参数的阀值时，该边框才会出现在
后续的图像库边框的合并过程。
\end_layout

\begin_layout Standard
IoUThresholdForNMS。使用NMS算法合并各个图像块中的边框时，该参数指定NMS算法中的那个IoU阀值。
\end_layout

\begin_layout Standard
开发者需要人工查看检测结果，为上述参数设定合适的值。
\end_layout

\begin_layout Subsubsection
网络输出
\end_layout

\begin_layout Standard
调用OpenCV的类Net的forward()成员函数，可以执行网络的前向计算。随着所使用的神经网络模型的不同，网络输出的张量的形状、内容也会不同。对于我们所使
用的SSD模型，网络包含了最后的那个NMS层，整个网络的输出是前100个置信度最高的目标。输出的张量的形状为（1, 1, 100, 7），每个目标的信息被存放在
一个长度为7的向量中，该向量的内容为（0, classID, confidence, leftTopX, leftTopY, rightBottomX,
 rightBottomY）。最后这4个量并非以像素为单位；它们的测量方法是认为图像左上角的坐标为（0.0, 0.0），而右下角的坐标为（1.0, 1.0）。
\end_layout

\begin_layout Subsubsection
各个图像块的检测结果的合并
\end_layout

\begin_layout Standard
由于我们对原始图像分块时两个相邻的块之间有重叠，所以检测结果中可能会出现同一个目标（行人）对应着多个检测结果的情形，如下图中的行人A、B、C。为了使得检测结果没
有这种冗余信息，我们可以对这个结果执行一个NMS。
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/needNMSWhenMerging.png

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
通过调用OpenCV/DNN模块中的NMSBoxes()函数，对于前文的那张图，经过NMS处理之后的结果如下图：
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/after_applying_NMS.png

\end_inset


\end_layout

\begin_layout Subsubsection
标注
\end_layout

\begin_layout Standard
标注检测结果时，我们会在检测框的左上角显示对应的置信度。如果两个检测框的左上角距离很近，会导致置信度文字重叠，不利于阅读。解决的方法是，绘制时检测这样潜在的重叠
，将后来绘制的置信度向左上45°偏移，然后绘制一条线段指向这个置信度对应的边框，例如下图的置信度“0.61”。
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/avoid_annotation_overlapping.png

\end_inset


\end_layout

\begin_layout Subsubsection
输出H5文件的目录结构
\end_layout

\begin_layout Standard
输出的H5文件主要含有检测到的行人的置信度以及边框信息。其目录结构如下。
\end_layout

\begin_layout Verbatim
sequenceNumber            # Depth数据集中总的序列（驾次）的数目。
\end_layout

\begin_layout Verbatim
seq_n                     # 序列n的数据
\end_layout

\begin_layout Verbatim
    leftImages            # 类型为vector<string>，第k个元素存放第k帧的左目相机的图像的路径。例如：
\end_layout

\begin_layout Verbatim
                          # /sw/cv/dbase/kittiRaw/Road/2011_10_03/2011_10_03_dri
ve_0042_sync/image_02/
\end_layout

\begin_layout Verbatim
                          #   data/0000001164.png
\end_layout

\begin_layout Verbatim
    frame_k               # 第k帧的数据
\end_layout

\begin_layout Verbatim
        confidences       # 类型为vector<float>，第i个元素存放检测到的第i个行人的置信度。
\end_layout

\begin_layout Verbatim
        boxes             # 类型为Eigen::MatrixXd，每列4行，存放一个边框的x,y,w,h信息。
\end_layout

\begin_layout Standard
为了查看检测结果，我们也会生成一些图像文件。这些图像文件在文件系统中的组织如下。输出目录含有若干“seq_n”子目录，每个子目录存放第n个序列的标注结果。在每个
子目录中，如果该序列的第k帧图像的检测结果中含有行人，则会生成一个图像文件frame_k_annotated.png，以呈现标注结果。如果一个帧的检测结果没有行人
，则不会生成上述标注文件。
\end_layout

\begin_layout Subsubsection
将来必须寻找比MobileNet-SSD更好的模型
\end_layout

\begin_layout Standard
依据MobileNet的原创论文（@mecnn-17），该模型在CV任务中的性能一般或者很差。例如，论文Table 13给出的在COCO目标检测任务中的mAP只
能达到20%。线索如下：
\end_layout

\begin_layout Standard
https://viso.ai/deep-learning/object-detection/，综述目标检测领域
\end_layout

\begin_layout Standard
https://docs.openvino.ai/2023.2/omz_models_group_public.html
\end_layout

\begin_layout Standard
@itao2-18，2018年，针对KITTI数据集，改动SSD，以获得更好检测性能。
\end_layout

\begin_layout Itemize
打开HDF5文件，创建新的HDF5文件和组，遍历文件中的对象，进行行人检测并保存结果，最后关闭文件和组。（目前仅选中了一个组进行尝试，发现h5读取有问题）
\end_layout

\begin_layout Subsection
程序test_v2.cpp
\end_layout

\begin_layout Section
障碍物检测完成之后的行为决策
\end_layout

\begin_layout Subsection
@rni-20
\end_layout

\begin_layout Standard
使用神经网络来模拟人在一个环境中如何避障行走。假设已经完成对环境的感知（静态以及到动态物体检测）。
\end_layout

\end_body
\end_document
